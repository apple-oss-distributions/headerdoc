FrT;@1|>>0|$15|HeaderDoc::Test%26|$4|CODE$7|COMMENT$7|CPPCODE$15|EXPECTED_RESULT$23|EXPECTED_RESULT_ALLDECS$7|FAILMSG$8|FILENAME$4|LANG$4|NAME$6|RESULT$14|RESULT_ALLDECS$7|SUBLANG$4|TYPE$8689|class OSMetaClassBase
{
public:
/*! @function OSTypeAlloc
    @abstract Allocate an instance of the desired object.
    @discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
    @param type Name of the desired type to be created.
    @result 'this' if object cas been successfully created.
*/
#define OSTypeAlloc(type)	((type *) ((type::metaClass)->alloc()))

/*! @function OSTypeID
    @abstract Given the name of a class return it's typeID
    @param type Name of the desired type, eg. OSObject.
    @result A unique Type ID for the class.
*/
#define OSTypeID(type)	(type::metaClass)

/*! @function OSTypeIDInst
    @abstract Given a pointer to an object return it's typeID
    @param typeinst An instance of an OSObject subclass.
    @result The typeID, ie. OSMetaClass *.
*/
#define OSTypeIDInst(typeinst)	((typeinst)->getMetaClass())

/*! @function OSDynamicCast
    @abstract Roughly analogous to (type *) inst, but check if valid first.
    @discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
    @param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.	Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
    @param inst Pointer to object that you wish to attempt to type cast.  May be 0.
    @result inst if object non-zero and it is of the desired type, otherwise 0.
*/
#define OSDynamicCast(type, inst)	\
    ((type *) OSMetaClassBase::safeMetaCast((inst), OSTypeID(type)))

/*! @function OSCheckTypeInst
    @abstract Is the target object a subclass of the reference object?
    @param typeinst Reference instance of an object, desired type.
    @param inst Instance of object to check for type compatibility.
    @result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
*/
#define OSCheckTypeInst(typeinst, inst) \
    OSMetaClassBase::checkTypeInst(inst, typeinst)
    

// Arcane evil code interprets a C++ pointer to function as specified in the
// -fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
// the conversion of functions that are from MULTIPLY inherited classes.

typedef void (*_ptf_t)(void);

static inline _ptf_t
_ptmf2ptf(const OSMetaClassBase *self, void (OSMetaClassBase::*func)(void))
{
    union {
	void (OSMetaClassBase::*fIn)(void);
	struct { 	// Pointer to member function 2.95
	    unsigned short fToff;
	    short  fVInd;
	    union {
		_ptf_t fPFN;
		short  fVOff;
	    } u;
	} fptmf2;
    } map;

    map.fIn = func;
    if (map.fptmf2.fToff) {
	panic("Multiple inheritance is not supported");
	return 0;
    } else if (map.fptmf2.fVInd < 0) {
	// Not virtual, i.e. plain member func
	return map.fptmf2.u.fPFN;
    } else {
	union {
	    const OSMetaClassBase *fObj;
	    _ptf_t **vtablep;
	} u;
	u.fObj = self;

	// Virtual member function so dereference vtable
	return (*u.vtablep)[map.fptmf2.fVInd - 1];
    }
}

/*! @function OSMemberFunctionCast
    @abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
    @param type The type of pointer function desired.
    @param self The this pointer of the object whose function you wish to cache.
    @param func The pointer to member function itself, something like &Base::func.
    @result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
*/

#define OSMemberFunctionCast(cptrtype, self, func)			\
    (cptrtype) OSMetaClassBase::					\
	    _ptmf2ptf(self, (void (OSMetaClassBase::*)(void)) func)

protected:
    OSMetaClassBase();
    virtual ~OSMetaClassBase();

private:
    // Disable copy constructors of OSMetaClassBase based objects
/*! @function operator =
    @abstract Disable implicit copy constructor by making private
    @param src Reference to source object that isn't allowed to be copied
*/
    void operator =(OSMetaClassBase &src);

/*! @function OSMetaClassBase
    @abstract Disable implicit copy constructor by making private
    @param src Reference to source object that isn't allowed to be copied
*/
    OSMetaClassBase(OSMetaClassBase &src);

public:
/*! @function release
    @abstract Primary implementation of the release mechanism.
    @discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
    @param when When retainCount == when then call free(). */
    virtual void release(int when) const = 0;

/*! @function getRetainCount
    @abstract How many times has this object been retained?
    @result Current retain count
*/
    virtual int getRetainCount() const = 0;

/*! @function retain
    @abstract Retain a reference in this object.
*/
    virtual void retain() const = 0;
/*! @function release
    @abstract Release a reference to this object
*/
    virtual void release() const = 0;

/*! @function serialize
    @abstract 
    @discussion 
    @param s
    @result 
*/
    virtual bool serialize(OSSerialize *s) const = 0;

    virtual const OSMetaClass * getMetaClass() const = 0;

/*! @function isEqualTo
    @abstract Is this == anObj?
    @discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
    @param anObj Object to compare 'this' to.
    @result true if the objects are equivalent, false otherwise.
*/
    virtual bool isEqualTo(const OSMetaClassBase *anObj) const;

/*! @function metaCast
    @abstract Check to see if this object is or inherits from the given type.
    @discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
    @param toMeta Pointer to a constant OSMetaClass for the desired target type.
    @result 'this' if object is of desired type, otherwise 0.
*/
    OSMetaClassBase *metaCast(const OSMetaClass *toMeta) const;


/*! @function metaCast
    @abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
    @param toMeta OSSymbol of the desired class' name.
    @result 'this' if object is of desired type, otherwise 0.
*/
    OSMetaClassBase *metaCast(const OSSymbol *toMeta) const;

/*! @function metaCast
    @abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
    @param toMeta OSString of the desired class' name.
    @result 'this' if object is of desired type, otherwise 0.
*/
    OSMetaClassBase *metaCast(const OSString *toMeta) const;

/*! @function metaCast
    @abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
    @param toMeta const char * C String of the desired class' name.
    @result 'this' if object is of desired type, otherwise 0.
*/
    OSMetaClassBase *metaCast(const char *toMeta) const;

    // Helper inlines for runtime type preprocessor macros
    static OSMetaClassBase *
    safeMetaCast(const OSMetaClassBase *me, const OSMetaClass *toType);

    static bool
    checkTypeInst(const OSMetaClassBase *inst, const OSMetaClassBase *typeinst);

public:

/*! @function taggedRetain
    @abstract Retain a tagged reference in this object.
*/
    // WAS: virtual void _RESERVEDOSMetaClassBase0();
    virtual void taggedRetain(const void *tag = 0) const = 0;

/*! @function taggedRelease
    @abstract Release a tagged reference to this object
*/
    // WAS:  virtual void _RESERVEDOSMetaClassBase1();
    virtual void taggedRelease(const void *tag = 0) const = 0;

protected:
/*! @function taggedRelease
    @abstract Release a tagged reference to this object and free if retainCount == when on entry
*/
    // WAS:  virtual void _RESERVEDOSMetaClassBase2();
    virtual void taggedRelease(const void *tag, const int when) const = 0;

private:
    // Virtual Padding
    virtual void _RESERVEDOSMetaClassBase3();
    virtual void _RESERVEDOSMetaClassBase4();
    virtual void _RESERVEDOSMetaClassBase5();
    virtual void _RESERVEDOSMetaClassBase6();
    virtual void _RESERVEDOSMetaClassBase7();
};
$23|/*! OSMetaClassBase */
$0|$393396|-=: TOP LEVEL COMMENT PARSE VALUES :=-
inHeader: 0
inClass: 0
inInterface: 0
inCPPHeader: 0
inOCCHeader: 0
inPerlScript: 0
inShellScript: 0
inPHPScript: 0
inJavaSource: 0
inFunctionGroup: 0
inGroup: 0
inFunction: 0
inPDefine: 0
inTypedef: 0
inUnion: 0
inStruct: 0
inConstant: 0
inVar: 0
inEnum: 0
inMethod: 0
inAvailabilityMacro: 0
inUnknown: 1
classType: unknown
inputCounter: 0
blockOffset: 0
fullpath: /test_suite_bogus_path/class_4.test
-=: BLOCKPARSE PARSER STATE KEYS :=-
$parserState->{FULLPATH} => /test_suite_bogus_path/class_4.test
$parserState->{ISFORWARDDECLARATION} => 0
$parserState->{NEXTTOKENNOCPP} => 0
$parserState->{availability} => 
$parserState->{backslashcount} => 0
$parserState->{basetype} => 
$parserState->{bracePending} => 0
$parserState->{callbackIsTypedef} => 0
$parserState->{callbackName} => 
$parserState->{callbackNamePending} => -1
$parserState->{categoryClass} => 
$parserState->{classNameFound} => 1
$parserState->{classtype} => class
$parserState->{forceClassDone} => 1
$parserState->{freezeStack} => ARRAY(OBJID)
$parserState->{freezereturn} => 1
$parserState->{frozensodname} => 
$parserState->{functionReturnsCallback} => 0
$parserState->{hollow} => HeaderDoc::ParseTree=HASH(OBJID)
$parserState->{inBrackets} => 0
$parserState->{inChar} => 0
$parserState->{inClass} => 1
$parserState->{inComment} => 0
$parserState->{inInlineComment} => 0
$parserState->{inMacro} => 0
$parserState->{inMacroLine} => 0
$parserState->{inOperator} => 0
$parserState->{inPrivateParamTypes} => 0
$parserState->{inString} => 0
$parserState->{inTemplate} => 0
$parserState->{initbsCount} => 0
$parserState->{inputCounter} => 142
$parserState->{kr_c_function} => 0
$parserState->{kr_c_name} => 
$parserState->{lang} => C
$parserState->{lastTreeNode} => HeaderDoc::ParseTree=HASH(OBJID)
$parserState->{lastsymbol} => ;
$parserState->{macroNoTrunc} => 1
$parserState->{name} => 
$parserState->{namePending} => 0
$parserState->{noInsert} => 0
$parserState->{occmethod} => 0
$parserState->{occmethodname} => 
$parserState->{occparmlabelfound} => 2
$parserState->{onlyComments} => 0
$parserState->{parsedParamList} => ARRAY(OBJID)
$parserState->{parsedParamParse} => 1
$parserState->{posstypes} => 
$parserState->{posstypesPending} => 0
$parserState->{pplStack} => ARRAY(OBJID)
$parserState->{preEqualsSymbol} => 
$parserState->{preTemplateSymbol} => 
$parserState->{preclasssodtype} => class
$parserState->{returntype} => class OSMetaClassBase  
$parserState->{seenBraces} => 0
$parserState->{seenMacroPart} => 0
$parserState->{seenTilde} => 0
$parserState->{simpleTDcontents} => 
$parserState->{simpleTypedef} => 0
$parserState->{sodclass} => class
$parserState->{sodname} => OSMetaClassBase
$parserState->{sodtype} => 
$parserState->{sodtypeclasstoken} => class
$parserState->{stackFrozen} => 0
$parserState->{startOfDec} => 1
$parserState->{storeDec} => 
$parserState->{temponlyComments} => 0
$parserState->{treePopTwo} => 0
$parserState->{typestring} => OSMetaClassBase
$parserState->{value} => 
$parserState->{valuepending} => 0
-=: BLOCKPARSE RETURN VALUES :=-
newcount: 142
typelist: class
namelist: OSMetaClassBase
posstypes: 
value: 
returntype: 
pridec: 
simpleTDcontents: 
bpavail: 
blockOffset: 79
conformsToList: 
functionContents: 
extendsClass: 
implementsClass: 
-=: LIST OF PARSED PARAMETERS :=-
-=: DUMP OF PARSE TREE :=-
+---class
+--- 
+---OSMetaClassBase
+---[ NEWLINE ]
+---{
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeAlloc
|   |   +---
@abstract Allocate an instance of the desired object.
|   |   +---
@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
|   |   +---
@param type Name of the desired type to be created.
|   |   +---
@result 'this' if object cas been successfully created.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeAlloc
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---alloc
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeID
|   |   +---
@abstract Given the name of a class return it's typeID
|   |   +---
@param type Name of the desired type, eg. OSObject.
|   |   +---
@result A unique Type ID for the class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeID
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeIDInst
|   |   +---
@abstract Given a pointer to an object return it's typeID
|   |   +---
@param typeinst An instance of an OSObject subclass.
|   |   +---
@result The typeID, ie. OSMetaClass *.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeIDInst
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---getMetaClass
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSDynamicCast
|   |   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   |   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   |   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   |   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   |   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSDynamicCast
|   |   +---(
|   |   +---type
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +---        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---safeMetaCast
|   |   +---(
|   |   +---(
|   |   +---inst
|   |   +---)
|   |   +---,
|   |   +---  
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSCheckTypeInst
|   |   +---
@abstract Is the target object a subclass of the reference object?
|   |   +---
@param typeinst Reference instance of an object, desired type.
|   |   +---
@param inst Instance of object to check for type compatibility.
|   |   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSCheckTypeInst
|   |   +---(
|   |   +---typeinst
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +--- 
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---checkTypeInst
|   |   +---(
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---typeinst
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---the conversion of functions that are from MULTIPLY inherited classes.
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-typedef (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---*
|   |   +---_ptf_t
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-static (HAS STATE)
|   +--- 
|   +---inline
|   +--- 
|   +---_ptf_t
|   +---[ NEWLINE ]
|   +---_ptmf2ptf
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   |   +---OSMetaClassBase
|   |   |   +---::
|   |   |   +---*
|   |   |   +---func
|   |   |   +---)
|   |   +---(
|   |   |   +---void
|   |   |   +---)
|   |   +---)
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMemberFunctionCast
|   |   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   |   +---
@param type The type of pointer function desired.
|   |   +---
@param self The this pointer of the object whose function you wish to cache.
|   |   +---
@param func The pointer to member function itself, something like &Base::func.
|   |   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSMemberFunctionCast
|   |   +---(
|   |   +---cptrtype
|   |   +---,
|   |   +--- 
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---cptrtype
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---                                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---            
|   |   +---_ptmf2ptf
|   |   +---(
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---(
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---)
|   |   +---(
|   |   +---void
|   |   +---)
|   |   +---)
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---~
|   +---OSMetaClassBase
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Disable copy constructors of OSMetaClassBase based objects
|   |   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function operator =
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-void (HAS STATE)
|   +--- 
|   +---operator
|   +--- 
|   +---=
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMetaClassBase
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Primary implementation of the release mechanism.
|   |   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   |   +---
@param when When retainCount == when then call free(). 
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function getRetainCount
|   |   +---
@abstract How many times has this object been retained?
|   |   +---
@result Current retain count
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---int
|   +--- 
|   +---getRetainCount
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function retain
|   |   +---
@abstract Retain a reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---retain
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Release a reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function serialize
|   |   +---
@abstract 
|   |   +---
@discussion 
|   |   +---
@param s
|   |   +---
@result 
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---serialize
|   +---(
|   |   +---OSSerialize
|   |   +--- 
|   |   +---*
|   |   +---s
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +--- 
|   +---getMetaClass
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function isEqualTo
|   |   +---
@abstract Is this == anObj?
|   |   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   |   +---
@param anObj Object to compare 'this' to.
|   |   +---
@result true if the objects are equivalent, false otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---isEqualTo
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---anObj
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract Check to see if this object is or inherits from the given type.
|   |   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   |   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSSymbol of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSSymbol
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSString of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSString
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta const char * C String of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---char
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Helper inlines for runtime type preprocessor macros
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---[ NEWLINE ]
|   +---    
|   +---safeMetaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---me
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toType
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---bool
|   +---[ NEWLINE ]
|   +---    
|   +---checkTypeInst
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---typeinst
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRetain
|   |   +---
@abstract Retain a tagged reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRetain
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Virtual Padding
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase3
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase4
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase5
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase6
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase7
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---}
+---;
+--- 
+---[ NEWLINE ]
-=: COMPUTED VALUE :=-
SUCCESS: 0
VALUE: 0
-=: CPP CHANGES :=-
$CPP_HASH{OSCheckTypeInst} => 
    OSMetaClassBase::checkTypeInst(inst, typeinst)
$CPP_HASH{OSDynamicCast} =>        
    ((type *) OSMetaClassBase::safeMetaCast((inst),  (type::metaClass)))
$CPP_HASH{OSMemberFunctionCast} =>                        
    (cptrtype) OSMetaClassBase::                                        
            _ptmf2ptf(self, (void (OSMetaClassBase::*)(void)) func)
$CPP_HASH{OSTypeAlloc} =>        ((type *) ((type::metaClass)->alloc()))
$CPP_HASH{OSTypeID} =>        (type::metaClass)
$CPP_HASH{OSTypeIDInst} =>        ((typeinst)->getMetaClass())
$CPP_ARG_HASH{OSCheckTypeInst} => typeinst, inst
$CPP_ARG_HASH{OSDynamicCast} => type, inst
$CPP_ARG_HASH{OSMemberFunctionCast} => cptrtype, self, func
$CPP_ARG_HASH{OSTypeAlloc} => type
$CPP_ARG_HASH{OSTypeID} => type
$CPP_ARG_HASH{OSTypeIDInst} => typeinst
-=: FOUND MATCH :=-
1
-=: NAMED OBJECTS :=-
TREE COUNT: 0
INDEX GROUP: 
IS BLOCK: 
OBJECT TYPE: HeaderDoc::Header
NAME: class 4
APIUID: //test_ref/doc/header/class_4.test
ABSTRACT: ""
DISCUSSION: "<p></p>"
UPDATED: ""
COPYRIGHT: ""
HTMLMETA: ""
PRIVATEDECLARATION: ""
GROUP: ""
INDEXGROUP: ""
THROWS: ""
XMLTHROWS: ""
UPDATED: ""
LINKAGESTATE: ""
ACCESSCONTROL: ""
AVAILABILITY: ""
LINKUID: ""
ORIGCLASS: ""
ISDEFINE: ""
ISTEMPLATE: ""
VALUE: "UNKNOWN"
RETURNTYPE: ""
LINENUM: ""
CLASS: "HeaderDoc::Header"
MASTERENUM: ""
APIREFSETUPDONE: "1"
TPCDONE: ""
NOREGISTERUID: ""
SUPPRESSCHILDREN: ""
NAMELINE_DISCUSSION: ""
HIDEDOC: ""
HIDESINGLETONS: ""
HIDECONTENTS: ""
MAINOBJECT: ""
LIST ATTRIBUTES: 
SHORT ATTRIBUTES: <p></p>
LONG ATTRIBUTES: <p></p>
    TREE COUNT: 1
    INDEX GROUP: 
    IS BLOCK: 
    OBJECT TYPE: HeaderDoc::CPPClass
    NAME: OSMetaClassBase
    APIUID: 
    ABSTRACT: ""
    DISCUSSION: "<p>OSMetaClassBase "
    UPDATED: ""
    COPYRIGHT: ""
    HTMLMETA: ""
    PRIVATEDECLARATION: ""
    GROUP: ""
    INDEXGROUP: ""
    THROWS: ""
    XMLTHROWS: ""
    UPDATED: ""
    LINKAGESTATE: ""
    ACCESSCONTROL: ""
    AVAILABILITY: ""
    LINKUID: ""
    ORIGCLASS: ""
    ISDEFINE: ""
    ISTEMPLATE: ""
    VALUE: "UNKNOWN"
    RETURNTYPE: ""
    LINENUM: ""
    CLASS: "HeaderDoc::CPPClass"
    MASTERENUM: ""
    APIREFSETUPDONE: "1"
    TPCDONE: ""
    NOREGISTERUID: ""
    SUPPRESSCHILDREN: "1"
    NAMELINE_DISCUSSION: ""
    HIDEDOC: ""
    HIDESINGLETONS: ""
    HIDECONTENTS: ""
    MAINOBJECT: ""
    LIST ATTRIBUTES: 
    SHORT ATTRIBUTES: <p><b>Declared In:</b> <a href="../../index.html" target="_top">class 4</a><br>
</p>
    LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: operator =
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/operator%3D/void/(OSMetaClassBase%26)
        ABSTRACT: "<p>Disable implicit copy constructor by making private
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: "     void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: OSMetaClassBase &
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference to source object that isn't allowed to be copied"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: OSMetaClassBase
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/OSMetaClassBase//(OSMetaClassBase%26)
        ABSTRACT: "<p>Disable implicit copy constructor by making private
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: OSMetaClassBase &
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference to source object that isn't allowed to be copied"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: release
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/release/void/(int)
        ABSTRACT: "<p>Primary implementation of the release mechanism.
"
        DISCUSSION: "<p>If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: int
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>When retainCount == when then call free()."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: getRetainCount
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/getRetainCount/int/()
        ABSTRACT: "<p>How many times has this object been retained?
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual int"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: retain
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/retain/void/()
        ABSTRACT: "<p>Retain a reference in this object.
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: release
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/release/void/()
        ABSTRACT: "<p>Release a reference to this object
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: serialize
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/serialize/bool/(OSSerialize*)
        ABSTRACT: ""
        DISCUSSION: "
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: s
            TYPE: OSSerialize *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: s
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: " "
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: isEqualTo
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/isEqualTo/bool/(constOSMetaClassBase*)
        ABSTRACT: "<p>Is this == anObj?
"
        DISCUSSION: "<p>OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: anObj
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: anObj
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Object to compare 'this' to."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSMetaClass*)
        ABSTRACT: "<p>Check to see if this object is or inherits from the given type.
"
        DISCUSSION: "<p>This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSMetaClass *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Pointer to a constant OSMetaClass for the desired target type."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSSymbol*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSSymbol *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>OSSymbol of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSString*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSString *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>OSString of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constchar*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const char *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>const char * C String of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRetain
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRetain/void/(constvoid*)
        ABSTRACT: "<p>Retain a tagged reference in this object.
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRelease
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRelease/void/(constvoid*)
        ABSTRACT: "<p>Release a tagged reference to this object
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRelease
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRelease/void/(constvoid*,constint)
        ABSTRACT: "<p>Release a tagged reference to this object and free if retainCount == when on entry
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "protected"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: const int
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeAlloc
        APIUID: //test_ref/cpp/macro/OSTypeAlloc
        ABSTRACT: "<p>Allocate an instance of the desired object.
"
        DISCUSSION: "<p>The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Name of the desired type to be created."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeID
        APIUID: //test_ref/cpp/macro/OSTypeID
        ABSTRACT: "<p>Given the name of a class return it's typeID
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Name of the desired type, eg. OSObject."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeIDInst
        APIUID: //test_ref/cpp/macro/OSTypeIDInst
        ABSTRACT: "<p>Given a pointer to an object return it's typeID
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>An instance of an OSObject subclass."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSDynamicCast
        APIUID: //test_ref/cpp/macro/OSDynamicCast
        ABSTRACT: "<p>Roughly analogous to (type *) inst, but check if valid first.
"
        DISCUSSION: "<p>OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Pointer to object that you wish to attempt to type cast.  May be 0."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSCheckTypeInst
        APIUID: //test_ref/cpp/macro/OSCheckTypeInst
        ABSTRACT: "<p>Is the target object a subclass of the reference object?
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference instance of an object, desired type."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Instance of object to check for type compatibility."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSMemberFunctionCast
        APIUID: //test_ref/cpp/macro/OSMemberFunctionCast
        ABSTRACT: "<p>Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: cptrtype
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: func
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The type of pointer function desired."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The this pointer of the object whose function you wish to cache."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: func
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The pointer to member function itself, something like &Base::func."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
-=: NAMED OBJECT PARSE TREES :=-
OBJECT: OSMetaClassBase (HeaderDoc::CPPClass)
+---class
+--- 
+---OSMetaClassBase
+---[ NEWLINE ]
+---{
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeAlloc
|   |   +---
@abstract Allocate an instance of the desired object.
|   |   +---
@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
|   |   +---
@param type Name of the desired type to be created.
|   |   +---
@result 'this' if object cas been successfully created.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeAlloc
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---alloc
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeID
|   |   +---
@abstract Given the name of a class return it's typeID
|   |   +---
@param type Name of the desired type, eg. OSObject.
|   |   +---
@result A unique Type ID for the class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeID
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeIDInst
|   |   +---
@abstract Given a pointer to an object return it's typeID
|   |   +---
@param typeinst An instance of an OSObject subclass.
|   |   +---
@result The typeID, ie. OSMetaClass *.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeIDInst
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---getMetaClass
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSDynamicCast
|   |   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   |   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   |   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   |   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   |   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSDynamicCast
|   |   +---(
|   |   +---type
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +---        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---safeMetaCast
|   |   +---(
|   |   +---(
|   |   +---inst
|   |   +---)
|   |   +---,
|   |   +---  
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSCheckTypeInst
|   |   +---
@abstract Is the target object a subclass of the reference object?
|   |   +---
@param typeinst Reference instance of an object, desired type.
|   |   +---
@param inst Instance of object to check for type compatibility.
|   |   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSCheckTypeInst
|   |   +---(
|   |   +---typeinst
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +--- 
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---checkTypeInst
|   |   +---(
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---typeinst
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---the conversion of functions that are from MULTIPLY inherited classes.
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-typedef (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---*
|   |   +---_ptf_t
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-static (HAS STATE)
|   +--- 
|   +---inline
|   +--- 
|   +---_ptf_t
|   +---[ NEWLINE ]
|   +---_ptmf2ptf
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   |   +---OSMetaClassBase
|   |   |   +---::
|   |   |   +---*
|   |   |   +---func
|   |   |   +---)
|   |   +---(
|   |   |   +---void
|   |   |   +---)
|   |   +---)
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMemberFunctionCast
|   |   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   |   +---
@param type The type of pointer function desired.
|   |   +---
@param self The this pointer of the object whose function you wish to cache.
|   |   +---
@param func The pointer to member function itself, something like &Base::func.
|   |   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSMemberFunctionCast
|   |   +---(
|   |   +---cptrtype
|   |   +---,
|   |   +--- 
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---cptrtype
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---                                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---            
|   |   +---_ptmf2ptf
|   |   +---(
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---(
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---)
|   |   +---(
|   |   +---void
|   |   +---)
|   |   +---)
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---~
|   +---OSMetaClassBase
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Disable copy constructors of OSMetaClassBase based objects
|   |   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function operator =
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-void (HAS STATE)
|   +--- 
|   +---operator
|   +--- 
|   +---=
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMetaClassBase
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Primary implementation of the release mechanism.
|   |   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   |   +---
@param when When retainCount == when then call free(). 
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function getRetainCount
|   |   +---
@abstract How many times has this object been retained?
|   |   +---
@result Current retain count
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---int
|   +--- 
|   +---getRetainCount
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function retain
|   |   +---
@abstract Retain a reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---retain
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Release a reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function serialize
|   |   +---
@abstract 
|   |   +---
@discussion 
|   |   +---
@param s
|   |   +---
@result 
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---serialize
|   +---(
|   |   +---OSSerialize
|   |   +--- 
|   |   +---*
|   |   +---s
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +--- 
|   +---getMetaClass
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function isEqualTo
|   |   +---
@abstract Is this == anObj?
|   |   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   |   +---
@param anObj Object to compare 'this' to.
|   |   +---
@result true if the objects are equivalent, false otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---isEqualTo
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---anObj
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract Check to see if this object is or inherits from the given type.
|   |   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   |   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSSymbol of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSSymbol
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSString of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSString
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta const char * C String of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---char
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Helper inlines for runtime type preprocessor macros
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---[ NEWLINE ]
|   +---    
|   +---safeMetaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---me
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toType
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---bool
|   +---[ NEWLINE ]
|   +---    
|   +---checkTypeInst
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---typeinst
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRetain
|   |   +---
@abstract Retain a tagged reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRetain
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Virtual Padding
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase3
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase4
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase5
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase6
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase7
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---}
+---;
+--- 
+---[ NEWLINE ]
END OF OBJECT


OBJECT: operator = (HeaderDoc::Function)
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: getRetainCount (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: retain (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: serialize (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: isEqualTo (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRetain (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeAlloc (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeAlloc
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---(
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +----
|   +--->
|   +---alloc
|   +---(
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeID
|   +---
@abstract Given the name of a class return it's typeID
|   +---
@param type Name of the desired type, eg. OSObject.
|   +---
@result A unique Type ID for the class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeID
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeIDInst
|   +---
@abstract Given a pointer to an object return it's typeID
|   +---
@param typeinst An instance of an OSObject subclass.
|   +---
@result The typeID, ie. OSMetaClass *.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeID (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeID
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeIDInst
|   +---
@abstract Given a pointer to an object return it's typeID
|   +---
@param typeinst An instance of an OSObject subclass.
|   +---
@result The typeID, ie. OSMetaClass *.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeIDInst (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSDynamicCast (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSCheckTypeInst (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMemberFunctionCast (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT



-=: HTML OUTPUT OF PARSE TREES :=-
OBJECT: OSMetaClassBase (HeaderDoc::CPPClass)
	<span class="keyword">class</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> { 
	    <span class="keyword">public</span>: <span class="comment">/*! @function OSTypeAlloc
	@abstract Allocate an instance of the desired object.
	@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
	@param type Name of the desired type to be created.
	@result 'this' if object cas been successfully created.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeAlloc //test_ref/cpp/tdef/OSTypeAlloc //test_ref/cpp/tag/OSTypeAlloc //test_ref/cpp/econst/OSTypeAlloc //test_ref/cpp/struct/OSTypeAlloc //test_ref/cpp/data/OSTypeAlloc //test_ref/cpp/clconst/OSTypeAlloc //test_ref/cpp/intf/OSTypeAlloc //test_ref/cpp/instm/OSTypeAlloc //test_ref/cpp/clm/OSTypeAlloc //test_ref/cpp/intfcm/OSTypeAlloc //test_ref/cpp/intfm/OSTypeAlloc //test_ref/cpp/func/OSTypeAlloc //test_ref/cpp/ftmplt/OSTypeAlloc //test_ref/cpp/defn/OSTypeAlloc //test_ref/cpp/macro/OSTypeAlloc //test_ref/doc/com/intfm/OSTypeAlloc" --><span class="preprocessor">OSTypeAlloc</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/alloc //test_ref/cpp/tdef/alloc //test_ref/cpp/tag/alloc //test_ref/cpp/econst/alloc //test_ref/cpp/struct/alloc //test_ref/cpp/data/alloc //test_ref/cpp/clconst/alloc //test_ref/cpp/intf/alloc //test_ref/cpp/instm/alloc //test_ref/cpp/clm/alloc //test_ref/cpp/intfcm/alloc //test_ref/cpp/intfm/alloc //test_ref/cpp/func/alloc //test_ref/cpp/ftmplt/alloc //test_ref/cpp/defn/alloc //test_ref/cpp/macro/alloc //test_ref/doc/com/intfm/alloc" --><span class="preprocessor">alloc</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSTypeID
	@abstract Given the name of a class return it's typeID
	@param type Name of the desired type, eg. OSObject.
	@result A unique Type ID for the class.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeID //test_ref/cpp/tdef/OSTypeID //test_ref/cpp/tag/OSTypeID //test_ref/cpp/econst/OSTypeID //test_ref/cpp/struct/OSTypeID //test_ref/cpp/data/OSTypeID //test_ref/cpp/clconst/OSTypeID //test_ref/cpp/intf/OSTypeID //test_ref/cpp/instm/OSTypeID //test_ref/cpp/clm/OSTypeID //test_ref/cpp/intfcm/OSTypeID //test_ref/cpp/intfm/OSTypeID //test_ref/cpp/func/OSTypeID //test_ref/cpp/ftmplt/OSTypeID //test_ref/cpp/defn/OSTypeID //test_ref/cpp/macro/OSTypeID //test_ref/doc/com/intfm/OSTypeID" --><span class="preprocessor">OSTypeID</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSTypeIDInst
	@abstract Given a pointer to an object return it's typeID
	@param typeinst An instance of an OSObject subclass.
	@result The typeID, ie. OSMetaClass *.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeIDInst //test_ref/cpp/tdef/OSTypeIDInst //test_ref/cpp/tag/OSTypeIDInst //test_ref/cpp/econst/OSTypeIDInst //test_ref/cpp/struct/OSTypeIDInst //test_ref/cpp/data/OSTypeIDInst //test_ref/cpp/clconst/OSTypeIDInst //test_ref/cpp/intf/OSTypeIDInst //test_ref/cpp/instm/OSTypeIDInst //test_ref/cpp/clm/OSTypeIDInst //test_ref/cpp/intfcm/OSTypeIDInst //test_ref/cpp/intfm/OSTypeIDInst //test_ref/cpp/func/OSTypeIDInst //test_ref/cpp/ftmplt/OSTypeIDInst //test_ref/cpp/defn/OSTypeIDInst //test_ref/cpp/macro/OSTypeIDInst //test_ref/doc/com/intfm/OSTypeIDInst" --><span class="preprocessor">OSTypeIDInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/getMetaClass //test_ref/cpp/tdef/getMetaClass //test_ref/cpp/tag/getMetaClass //test_ref/cpp/econst/getMetaClass //test_ref/cpp/struct/getMetaClass //test_ref/cpp/data/getMetaClass //test_ref/cpp/clconst/getMetaClass //test_ref/cpp/intf/getMetaClass //test_ref/cpp/instm/getMetaClass //test_ref/cpp/clm/getMetaClass //test_ref/cpp/intfcm/getMetaClass //test_ref/cpp/intfm/getMetaClass //test_ref/cpp/func/getMetaClass //test_ref/cpp/ftmplt/getMetaClass //test_ref/cpp/defn/getMetaClass //test_ref/cpp/macro/getMetaClass //test_ref/doc/com/intfm/getMetaClass" --><span class="preprocessor">getMetaClass</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSDynamicCast
	@abstract Roughly analogous to (type *) inst, but check if valid first.
	@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast&lt;T&gt; operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
	@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
	@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
	@result inst if object non-zero and it is of the desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSDynamicCast //test_ref/cpp/tdef/OSDynamicCast //test_ref/cpp/tag/OSDynamicCast //test_ref/cpp/econst/OSDynamicCast //test_ref/cpp/struct/OSDynamicCast //test_ref/cpp/data/OSDynamicCast //test_ref/cpp/clconst/OSDynamicCast //test_ref/cpp/intf/OSDynamicCast //test_ref/cpp/instm/OSDynamicCast //test_ref/cpp/clm/OSDynamicCast //test_ref/cpp/intfcm/OSDynamicCast //test_ref/cpp/intfm/OSDynamicCast //test_ref/cpp/func/OSDynamicCast //test_ref/cpp/ftmplt/OSDynamicCast //test_ref/cpp/defn/OSDynamicCast //test_ref/cpp/macro/OSDynamicCast //test_ref/doc/com/intfm/OSDynamicCast" --><span class="preprocessor">OSDynamicCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/safeMetaCast //test_ref/cpp/tdef/safeMetaCast //test_ref/cpp/tag/safeMetaCast //test_ref/cpp/econst/safeMetaCast //test_ref/cpp/struct/safeMetaCast //test_ref/cpp/data/safeMetaCast //test_ref/cpp/clconst/safeMetaCast //test_ref/cpp/intf/safeMetaCast //test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast //test_ref/doc/com/intfm/safeMetaCast" --><span class="preprocessor">safeMetaCast</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSCheckTypeInst
	@abstract Is the target object a subclass of the reference object?
	@param typeinst Reference instance of an object, desired type.
	@param inst Instance of object to check for type compatibility.
	@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSCheckTypeInst //test_ref/cpp/tdef/OSCheckTypeInst //test_ref/cpp/tag/OSCheckTypeInst //test_ref/cpp/econst/OSCheckTypeInst //test_ref/cpp/struct/OSCheckTypeInst //test_ref/cpp/data/OSCheckTypeInst //test_ref/cpp/clconst/OSCheckTypeInst //test_ref/cpp/intf/OSCheckTypeInst //test_ref/cpp/instm/OSCheckTypeInst //test_ref/cpp/clm/OSCheckTypeInst //test_ref/cpp/intfcm/OSCheckTypeInst //test_ref/cpp/intfm/OSCheckTypeInst //test_ref/cpp/func/OSCheckTypeInst //test_ref/cpp/ftmplt/OSCheckTypeInst //test_ref/cpp/defn/OSCheckTypeInst //test_ref/cpp/macro/OSCheckTypeInst //test_ref/doc/com/intfm/OSCheckTypeInst" --><span class="preprocessor">OSCheckTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/checkTypeInst //test_ref/cpp/tdef/checkTypeInst //test_ref/cpp/tag/checkTypeInst //test_ref/cpp/econst/checkTypeInst //test_ref/cpp/struct/checkTypeInst //test_ref/cpp/data/checkTypeInst //test_ref/cpp/clconst/checkTypeInst //test_ref/cpp/intf/checkTypeInst //test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst //test_ref/doc/com/intfm/checkTypeInst" --><span class="preprocessor">checkTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span>   
	    <span class="comment">// Arcane evil code interprets a C++ pointer to function as specified in the</span> 
	    <span class="comment">// -fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW</span> 
	    <span class="comment">// the conversion of functions that are from MULTIPLY inherited classes.</span>  
	    <span class="keyword">typedef</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> (<span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/_ptf_t //test_ref/cpp/clm/_ptf_t //test_ref/cpp/intfcm/_ptf_t //test_ref/cpp/intfm/_ptf_t //test_ref/cpp/func/_ptf_t //test_ref/cpp/ftmplt/_ptf_t //test_ref/cpp/defn/_ptf_t //test_ref/cpp/macro/_ptf_t" --><span class="function">_ptf_t</span><!-- /a -->)(
	        <span class="param">void</span>);  
	    <span class="keyword">static</span> <span class="keyword">inline</span> <!-- a logicalPath="//test_ref/cpp/cl/_ptf_t //test_ref/cpp/tdef/_ptf_t //test_ref/cpp/tag/_ptf_t //test_ref/cpp/econst/_ptf_t //test_ref/cpp/struct/_ptf_t //test_ref/cpp/clconst/_ptf_t //test_ref/cpp/intf/_ptf_t" --><span class="type">_ptf_t</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf" --><span class="function">_ptmf2ptf</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/self //test_ref/cpp/data/self" --><span class="var">self</span><!-- /a -->,
	        <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> (<!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a -->::<span class="type">*</span><span class="param">func</span>)(<!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a -->))   <span class="comment">/*! @function OSMemberFunctionCast
	@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
	@param type The type of pointer function desired.
	@param self The this pointer of the object whose function you wish to cache.
	@param func The pointer to member function itself, something like &amp;Base::func.
	@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMemberFunctionCast //test_ref/cpp/tdef/OSMemberFunctionCast //test_ref/cpp/tag/OSMemberFunctionCast //test_ref/cpp/econst/OSMemberFunctionCast //test_ref/cpp/struct/OSMemberFunctionCast //test_ref/cpp/data/OSMemberFunctionCast //test_ref/cpp/clconst/OSMemberFunctionCast //test_ref/cpp/intf/OSMemberFunctionCast //test_ref/cpp/instm/OSMemberFunctionCast //test_ref/cpp/clm/OSMemberFunctionCast //test_ref/cpp/intfcm/OSMemberFunctionCast //test_ref/cpp/intfm/OSMemberFunctionCast //test_ref/cpp/func/OSMemberFunctionCast //test_ref/cpp/ftmplt/OSMemberFunctionCast //test_ref/cpp/defn/OSMemberFunctionCast //test_ref/cpp/macro/OSMemberFunctionCast //test_ref/doc/com/intfm/OSMemberFunctionCast" --><span class="preprocessor">OSMemberFunctionCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <!-- a logicalPath="//test_ref/cpp/cl/_ptmf2ptf //test_ref/cpp/tdef/_ptmf2ptf //test_ref/cpp/tag/_ptmf2ptf //test_ref/cpp/econst/_ptmf2ptf //test_ref/cpp/struct/_ptmf2ptf //test_ref/cpp/data/_ptmf2ptf //test_ref/cpp/clconst/_ptmf2ptf //test_ref/cpp/intf/_ptmf2ptf //test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf //test_ref/doc/com/intfm/_ptmf2ptf" --><span class="preprocessor">_ptmf2ptf</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span>  
	    <span class="keyword">protected</span>: <!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> ~<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->();  
	    <span class="keyword">private</span>: <span class="comment">// Disable copy constructors of OSMetaClassBase based objects</span> 
	    <span class="comment">/*! @function operator =
	@abstract Disable implicit copy constructor by making private
	@param src Reference to source object that isn't allowed to be copied</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <span class="keyword">operator</span> =(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>);  
	    <span class="comment">/*! @function OSMetaClassBase
	@abstract Disable implicit copy constructor by making private
	@param src Reference to source object that isn't allowed to be copied</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>);  
	    <span class="keyword">public</span>: <span class="comment">/*! @function release
	@abstract Primary implementation of the release mechanism.
	@discussion  If $link retainCount &lt;= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. </span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <span class="param">when</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function getRetainCount
	@abstract How many times has this object been retained?
	@result Current retain count</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/getRetainCount //test_ref/cpp/clm/getRetainCount //test_ref/cpp/intfcm/getRetainCount //test_ref/cpp/intfm/getRetainCount //test_ref/cpp/func/getRetainCount //test_ref/cpp/ftmplt/getRetainCount //test_ref/cpp/defn/getRetainCount //test_ref/cpp/macro/getRetainCount" --><span class="function">getRetainCount</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function retain
	@abstract Retain a reference in this object.</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/retain //test_ref/cpp/clm/retain //test_ref/cpp/intfcm/retain //test_ref/cpp/intfm/retain //test_ref/cpp/func/retain //test_ref/cpp/ftmplt/retain //test_ref/cpp/defn/retain //test_ref/cpp/macro/retain" --><span class="function">retain</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
	    <span class="comment">/*! @function release
	@abstract Release a reference to this object</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function serialize
	@abstract 
	@discussion 
	@param s
	@result </span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/serialize //test_ref/cpp/clm/serialize //test_ref/cpp/intfcm/serialize //test_ref/cpp/intfm/serialize //test_ref/cpp/func/serialize //test_ref/cpp/ftmplt/serialize //test_ref/cpp/defn/serialize //test_ref/cpp/macro/serialize" --><span class="function">serialize</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSSerialize //test_ref/cpp/tdef/OSSerialize //test_ref/cpp/tag/OSSerialize //test_ref/cpp/econst/OSSerialize //test_ref/cpp/struct/OSSerialize //test_ref/cpp/clconst/OSSerialize //test_ref/cpp/intf/OSSerialize" --><span class="type">OSSerialize</span><!-- /a --> <span class="type">*</span><span class="param">s</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span> <!-- a logicalPath="//test_ref/cpp/econst/getMetaClass //test_ref/cpp/data/getMetaClass" --><span class="var">getMetaClass</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function isEqualTo
	@abstract Is this == anObj?
	@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
	@param anObj Object to compare 'this' to.
	@result true if the objects are equivalent, false otherwise.</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/isEqualTo //test_ref/cpp/clm/isEqualTo //test_ref/cpp/intfcm/isEqualTo //test_ref/cpp/intfm/isEqualTo //test_ref/cpp/func/isEqualTo //test_ref/cpp/ftmplt/isEqualTo //test_ref/cpp/defn/isEqualTo //test_ref/cpp/macro/isEqualTo" --><span class="function">isEqualTo</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/anObj //test_ref/cpp/data/anObj" --><span class="var">anObj</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract Check to see if this object is or inherits from the given type.
	@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
	@param toMeta Pointer to a constant OSMetaClass for the desired target type.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;   
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta OSSymbol of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSSymbol //test_ref/cpp/data/OSSymbol" --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta OSString of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSString //test_ref/cpp/data/OSString" --><span class="var">OSString</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta const char * C String of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/char //test_ref/cpp/data/char" --><span class="var">char</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">// Helper inlines for runtime type preprocessor macros</span> 
	    <span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span> <!-- a logicalPath="//test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast" --><span class="function">safeMetaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/me //test_ref/cpp/data/me" --><span class="var">me</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toType //test_ref/cpp/data/toType" --><span class="var">toType</span><!-- /a -->);  
	    <span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst" --><span class="function">checkTypeInst</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/inst //test_ref/cpp/data/inst" --><span class="var">inst</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/typeinst //test_ref/cpp/data/typeinst" --><span class="var">typeinst</span><!-- /a -->);  
	    <span class="keyword">public</span>:  <span class="comment">/*! @function taggedRetain
	@abstract Retain a tagged reference in this object.</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS: virtual void _RESERVEDOSMetaClassBase0();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRetain //test_ref/cpp/clm/taggedRetain //test_ref/cpp/intfcm/taggedRetain //test_ref/cpp/intfm/taggedRetain //test_ref/cpp/func/taggedRetain //test_ref/cpp/ftmplt/taggedRetain //test_ref/cpp/defn/taggedRetain //test_ref/cpp/macro/taggedRetain" --><span class="function">taggedRetain</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function taggedRelease
	@abstract Release a tagged reference to this object</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS:  virtual void _RESERVEDOSMetaClassBase1();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">protected</span>: <span class="comment">/*! @function taggedRelease
	@abstract Release a tagged reference to this object and free if retainCount == when on entry</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS:  virtual void _RESERVEDOSMetaClassBase2();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/int //test_ref/cpp/data/int" --><span class="var">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/econst/when //test_ref/cpp/data/when" --><span class="var">when</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">private</span>: <span class="comment">// Virtual Padding</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/func/_RESERVEDOSMetaClassBase3 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase3 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase3 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase3" --><span class="function">_RESERVEDOSMetaClassBase3</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/func/_RESERVEDOSMetaClassBase4 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase4 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase4 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase4" --><span class="function">_RESERVEDOSMetaClassBase4</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/func/_RESERVEDOSMetaClassBase5 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase5 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase5 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase5" --><span class="function">_RESERVEDOSMetaClassBase5</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/func/_RESERVEDOSMetaClassBase6 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase6 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase6 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase6" --><span class="function">_RESERVEDOSMetaClassBase6</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/func/_RESERVEDOSMetaClassBase7 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase7 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase7 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase7" --><span class="function">_RESERVEDOSMetaClassBase7</span><!-- /a -->(); 
	};  
END OF OBJECT


OBJECT: operator = (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <span class="keyword">operator</span> =(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>); 
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>); 
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <span class="param">when</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: getRetainCount (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/getRetainCount //test_ref/cpp/clm/getRetainCount //test_ref/cpp/intfcm/getRetainCount //test_ref/cpp/intfm/getRetainCount //test_ref/cpp/func/getRetainCount //test_ref/cpp/ftmplt/getRetainCount //test_ref/cpp/defn/getRetainCount //test_ref/cpp/macro/getRetainCount" --><span class="function">getRetainCount</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: retain (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/retain //test_ref/cpp/clm/retain //test_ref/cpp/intfcm/retain //test_ref/cpp/intfm/retain //test_ref/cpp/func/retain //test_ref/cpp/ftmplt/retain //test_ref/cpp/defn/retain //test_ref/cpp/macro/retain" --><span class="function">retain</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: serialize (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/serialize //test_ref/cpp/clm/serialize //test_ref/cpp/intfcm/serialize //test_ref/cpp/intfm/serialize //test_ref/cpp/func/serialize //test_ref/cpp/ftmplt/serialize //test_ref/cpp/defn/serialize //test_ref/cpp/macro/serialize" --><span class="function">serialize</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSSerialize //test_ref/cpp/tdef/OSSerialize //test_ref/cpp/tag/OSSerialize //test_ref/cpp/econst/OSSerialize //test_ref/cpp/struct/OSSerialize //test_ref/cpp/clconst/OSSerialize //test_ref/cpp/intf/OSSerialize" --><span class="type">OSSerialize</span><!-- /a --> <span class="type">*</span><span class="param">s</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: isEqualTo (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/isEqualTo //test_ref/cpp/clm/isEqualTo //test_ref/cpp/intfcm/isEqualTo //test_ref/cpp/intfm/isEqualTo //test_ref/cpp/func/isEqualTo //test_ref/cpp/ftmplt/isEqualTo //test_ref/cpp/defn/isEqualTo //test_ref/cpp/macro/isEqualTo" --><span class="function">isEqualTo</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/anObj //test_ref/cpp/data/anObj" --><span class="var">anObj</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSSymbol //test_ref/cpp/data/OSSymbol" --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSString //test_ref/cpp/data/OSString" --><span class="var">OSString</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/char //test_ref/cpp/data/char" --><span class="var">char</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: taggedRetain (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRetain //test_ref/cpp/clm/taggedRetain //test_ref/cpp/intfcm/taggedRetain //test_ref/cpp/intfm/taggedRetain //test_ref/cpp/func/taggedRetain //test_ref/cpp/ftmplt/taggedRetain //test_ref/cpp/defn/taggedRetain //test_ref/cpp/macro/taggedRetain" --><span class="function">taggedRetain</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a -->,
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/int //test_ref/cpp/data/int" --><span class="var">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/econst/when //test_ref/cpp/data/when" --><span class="var">when</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: OSTypeAlloc (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeAlloc //test_ref/cpp/tdef/OSTypeAlloc //test_ref/cpp/tag/OSTypeAlloc //test_ref/cpp/econst/OSTypeAlloc //test_ref/cpp/struct/OSTypeAlloc //test_ref/cpp/data/OSTypeAlloc //test_ref/cpp/clconst/OSTypeAlloc //test_ref/cpp/intf/OSTypeAlloc //test_ref/cpp/instm/OSTypeAlloc //test_ref/cpp/clm/OSTypeAlloc //test_ref/cpp/intfcm/OSTypeAlloc //test_ref/cpp/intfm/OSTypeAlloc //test_ref/cpp/func/OSTypeAlloc //test_ref/cpp/ftmplt/OSTypeAlloc //test_ref/cpp/defn/OSTypeAlloc //test_ref/cpp/macro/OSTypeAlloc //test_ref/doc/com/intfm/OSTypeAlloc" --><span class="preprocessor">OSTypeAlloc</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/alloc //test_ref/cpp/tdef/alloc //test_ref/cpp/tag/alloc //test_ref/cpp/econst/alloc //test_ref/cpp/struct/alloc //test_ref/cpp/data/alloc //test_ref/cpp/clconst/alloc //test_ref/cpp/intf/alloc //test_ref/cpp/instm/alloc //test_ref/cpp/clm/alloc //test_ref/cpp/intfcm/alloc //test_ref/cpp/intfm/alloc //test_ref/cpp/func/alloc //test_ref/cpp/ftmplt/alloc //test_ref/cpp/defn/alloc //test_ref/cpp/macro/alloc //test_ref/doc/com/intfm/alloc" --><span class="preprocessor">alloc</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSTypeID (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeID //test_ref/cpp/tdef/OSTypeID //test_ref/cpp/tag/OSTypeID //test_ref/cpp/econst/OSTypeID //test_ref/cpp/struct/OSTypeID //test_ref/cpp/data/OSTypeID //test_ref/cpp/clconst/OSTypeID //test_ref/cpp/intf/OSTypeID //test_ref/cpp/instm/OSTypeID //test_ref/cpp/clm/OSTypeID //test_ref/cpp/intfcm/OSTypeID //test_ref/cpp/intfm/OSTypeID //test_ref/cpp/func/OSTypeID //test_ref/cpp/ftmplt/OSTypeID //test_ref/cpp/defn/OSTypeID //test_ref/cpp/macro/OSTypeID //test_ref/doc/com/intfm/OSTypeID" --><span class="preprocessor">OSTypeID</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSTypeIDInst (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeIDInst //test_ref/cpp/tdef/OSTypeIDInst //test_ref/cpp/tag/OSTypeIDInst //test_ref/cpp/econst/OSTypeIDInst //test_ref/cpp/struct/OSTypeIDInst //test_ref/cpp/data/OSTypeIDInst //test_ref/cpp/clconst/OSTypeIDInst //test_ref/cpp/intf/OSTypeIDInst //test_ref/cpp/instm/OSTypeIDInst //test_ref/cpp/clm/OSTypeIDInst //test_ref/cpp/intfcm/OSTypeIDInst //test_ref/cpp/intfm/OSTypeIDInst //test_ref/cpp/func/OSTypeIDInst //test_ref/cpp/ftmplt/OSTypeIDInst //test_ref/cpp/defn/OSTypeIDInst //test_ref/cpp/macro/OSTypeIDInst //test_ref/doc/com/intfm/OSTypeIDInst" --><span class="preprocessor">OSTypeIDInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/getMetaClass //test_ref/cpp/tdef/getMetaClass //test_ref/cpp/tag/getMetaClass //test_ref/cpp/econst/getMetaClass //test_ref/cpp/struct/getMetaClass //test_ref/cpp/data/getMetaClass //test_ref/cpp/clconst/getMetaClass //test_ref/cpp/intf/getMetaClass //test_ref/cpp/instm/getMetaClass //test_ref/cpp/clm/getMetaClass //test_ref/cpp/intfcm/getMetaClass //test_ref/cpp/intfm/getMetaClass //test_ref/cpp/func/getMetaClass //test_ref/cpp/ftmplt/getMetaClass //test_ref/cpp/defn/getMetaClass //test_ref/cpp/macro/getMetaClass //test_ref/doc/com/intfm/getMetaClass" --><span class="preprocessor">getMetaClass</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSDynamicCast (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSDynamicCast //test_ref/cpp/tdef/OSDynamicCast //test_ref/cpp/tag/OSDynamicCast //test_ref/cpp/econst/OSDynamicCast //test_ref/cpp/struct/OSDynamicCast //test_ref/cpp/data/OSDynamicCast //test_ref/cpp/clconst/OSDynamicCast //test_ref/cpp/intf/OSDynamicCast //test_ref/cpp/instm/OSDynamicCast //test_ref/cpp/clm/OSDynamicCast //test_ref/cpp/intfcm/OSDynamicCast //test_ref/cpp/intfm/OSDynamicCast //test_ref/cpp/func/OSDynamicCast //test_ref/cpp/ftmplt/OSDynamicCast //test_ref/cpp/defn/OSDynamicCast //test_ref/cpp/macro/OSDynamicCast //test_ref/doc/com/intfm/OSDynamicCast" --><span class="preprocessor">OSDynamicCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/safeMetaCast //test_ref/cpp/tdef/safeMetaCast //test_ref/cpp/tag/safeMetaCast //test_ref/cpp/econst/safeMetaCast //test_ref/cpp/struct/safeMetaCast //test_ref/cpp/data/safeMetaCast //test_ref/cpp/clconst/safeMetaCast //test_ref/cpp/intf/safeMetaCast //test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast //test_ref/doc/com/intfm/safeMetaCast" --><span class="preprocessor">safeMetaCast</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSCheckTypeInst (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSCheckTypeInst //test_ref/cpp/tdef/OSCheckTypeInst //test_ref/cpp/tag/OSCheckTypeInst //test_ref/cpp/econst/OSCheckTypeInst //test_ref/cpp/struct/OSCheckTypeInst //test_ref/cpp/data/OSCheckTypeInst //test_ref/cpp/clconst/OSCheckTypeInst //test_ref/cpp/intf/OSCheckTypeInst //test_ref/cpp/instm/OSCheckTypeInst //test_ref/cpp/clm/OSCheckTypeInst //test_ref/cpp/intfcm/OSCheckTypeInst //test_ref/cpp/intfm/OSCheckTypeInst //test_ref/cpp/func/OSCheckTypeInst //test_ref/cpp/ftmplt/OSCheckTypeInst //test_ref/cpp/defn/OSCheckTypeInst //test_ref/cpp/macro/OSCheckTypeInst //test_ref/doc/com/intfm/OSCheckTypeInst" --><span class="preprocessor">OSCheckTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/checkTypeInst //test_ref/cpp/tdef/checkTypeInst //test_ref/cpp/tag/checkTypeInst //test_ref/cpp/econst/checkTypeInst //test_ref/cpp/struct/checkTypeInst //test_ref/cpp/data/checkTypeInst //test_ref/cpp/clconst/checkTypeInst //test_ref/cpp/intf/checkTypeInst //test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst //test_ref/doc/com/intfm/checkTypeInst" --><span class="preprocessor">checkTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSMemberFunctionCast (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMemberFunctionCast //test_ref/cpp/tdef/OSMemberFunctionCast //test_ref/cpp/tag/OSMemberFunctionCast //test_ref/cpp/econst/OSMemberFunctionCast //test_ref/cpp/struct/OSMemberFunctionCast //test_ref/cpp/data/OSMemberFunctionCast //test_ref/cpp/clconst/OSMemberFunctionCast //test_ref/cpp/intf/OSMemberFunctionCast //test_ref/cpp/instm/OSMemberFunctionCast //test_ref/cpp/clm/OSMemberFunctionCast //test_ref/cpp/intfcm/OSMemberFunctionCast //test_ref/cpp/intfm/OSMemberFunctionCast //test_ref/cpp/func/OSMemberFunctionCast //test_ref/cpp/ftmplt/OSMemberFunctionCast //test_ref/cpp/defn/OSMemberFunctionCast //test_ref/cpp/macro/OSMemberFunctionCast //test_ref/doc/com/intfm/OSMemberFunctionCast" --><span class="preprocessor">OSMemberFunctionCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <!-- a logicalPath="//test_ref/cpp/cl/_ptmf2ptf //test_ref/cpp/tdef/_ptmf2ptf //test_ref/cpp/tag/_ptmf2ptf //test_ref/cpp/econst/_ptmf2ptf //test_ref/cpp/struct/_ptmf2ptf //test_ref/cpp/data/_ptmf2ptf //test_ref/cpp/clconst/_ptmf2ptf //test_ref/cpp/intf/_ptmf2ptf //test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf //test_ref/doc/com/intfm/_ptmf2ptf" --><span class="preprocessor">_ptmf2ptf</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT



$482950|-=: TOP LEVEL COMMENT PARSE VALUES :=-
inHeader: 0
inClass: 0
inInterface: 0
inCPPHeader: 0
inOCCHeader: 0
inPerlScript: 0
inShellScript: 0
inPHPScript: 0
inJavaSource: 0
inFunctionGroup: 0
inGroup: 0
inFunction: 0
inPDefine: 0
inTypedef: 0
inUnion: 0
inStruct: 0
inConstant: 0
inVar: 0
inEnum: 0
inMethod: 0
inAvailabilityMacro: 0
inUnknown: 1
classType: unknown
inputCounter: 0
blockOffset: 0
fullpath: /test_suite_bogus_path/class_4.test
-=: BLOCKPARSE PARSER STATE KEYS :=-
$parserState->{FULLPATH} => /test_suite_bogus_path/class_4.test
$parserState->{ISFORWARDDECLARATION} => 0
$parserState->{NEXTTOKENNOCPP} => 0
$parserState->{availability} => 
$parserState->{backslashcount} => 0
$parserState->{basetype} => 
$parserState->{bracePending} => 0
$parserState->{callbackIsTypedef} => 0
$parserState->{callbackName} => 
$parserState->{callbackNamePending} => -1
$parserState->{categoryClass} => 
$parserState->{classNameFound} => 1
$parserState->{classtype} => class
$parserState->{forceClassDone} => 1
$parserState->{freezeStack} => ARRAY(OBJID)
$parserState->{freezereturn} => 1
$parserState->{frozensodname} => 
$parserState->{functionReturnsCallback} => 0
$parserState->{hollow} => HeaderDoc::ParseTree=HASH(OBJID)
$parserState->{inBrackets} => 0
$parserState->{inChar} => 0
$parserState->{inClass} => 1
$parserState->{inComment} => 0
$parserState->{inInlineComment} => 0
$parserState->{inMacro} => 0
$parserState->{inMacroLine} => 0
$parserState->{inOperator} => 0
$parserState->{inPrivateParamTypes} => 0
$parserState->{inString} => 0
$parserState->{inTemplate} => 0
$parserState->{initbsCount} => 0
$parserState->{inputCounter} => 142
$parserState->{kr_c_function} => 0
$parserState->{kr_c_name} => 
$parserState->{lang} => C
$parserState->{lastTreeNode} => HeaderDoc::ParseTree=HASH(OBJID)
$parserState->{lastsymbol} => ;
$parserState->{macroNoTrunc} => 1
$parserState->{name} => 
$parserState->{namePending} => 0
$parserState->{noInsert} => 0
$parserState->{occmethod} => 0
$parserState->{occmethodname} => 
$parserState->{occparmlabelfound} => 2
$parserState->{onlyComments} => 0
$parserState->{parsedParamList} => ARRAY(OBJID)
$parserState->{parsedParamParse} => 1
$parserState->{posstypes} => 
$parserState->{posstypesPending} => 0
$parserState->{pplStack} => ARRAY(OBJID)
$parserState->{preEqualsSymbol} => 
$parserState->{preTemplateSymbol} => 
$parserState->{preclasssodtype} => class
$parserState->{returntype} => class OSMetaClassBase  
$parserState->{seenBraces} => 0
$parserState->{seenMacroPart} => 0
$parserState->{seenTilde} => 0
$parserState->{simpleTDcontents} => 
$parserState->{simpleTypedef} => 0
$parserState->{sodclass} => class
$parserState->{sodname} => OSMetaClassBase
$parserState->{sodtype} => 
$parserState->{sodtypeclasstoken} => class
$parserState->{stackFrozen} => 0
$parserState->{startOfDec} => 1
$parserState->{storeDec} => 
$parserState->{temponlyComments} => 0
$parserState->{treePopTwo} => 0
$parserState->{typestring} => OSMetaClassBase
$parserState->{value} => 
$parserState->{valuepending} => 0
-=: BLOCKPARSE RETURN VALUES :=-
newcount: 142
typelist: class
namelist: OSMetaClassBase
posstypes: 
value: 
returntype: 
pridec: 
simpleTDcontents: 
bpavail: 
blockOffset: 79
conformsToList: 
functionContents: 
extendsClass: 
implementsClass: 
-=: LIST OF PARSED PARAMETERS :=-
-=: DUMP OF PARSE TREE :=-
+---class
+--- 
+---OSMetaClassBase
+---[ NEWLINE ]
+---{
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeAlloc
|   |   +---
@abstract Allocate an instance of the desired object.
|   |   +---
@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
|   |   +---
@param type Name of the desired type to be created.
|   |   +---
@result 'this' if object cas been successfully created.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeAlloc
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---alloc
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeID
|   |   +---
@abstract Given the name of a class return it's typeID
|   |   +---
@param type Name of the desired type, eg. OSObject.
|   |   +---
@result A unique Type ID for the class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeID
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeIDInst
|   |   +---
@abstract Given a pointer to an object return it's typeID
|   |   +---
@param typeinst An instance of an OSObject subclass.
|   |   +---
@result The typeID, ie. OSMetaClass *.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeIDInst
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---getMetaClass
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSDynamicCast
|   |   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   |   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   |   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   |   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   |   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSDynamicCast
|   |   +---(
|   |   +---type
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +---        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---safeMetaCast
|   |   +---(
|   |   +---(
|   |   +---inst
|   |   +---)
|   |   +---,
|   |   +---  
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSCheckTypeInst
|   |   +---
@abstract Is the target object a subclass of the reference object?
|   |   +---
@param typeinst Reference instance of an object, desired type.
|   |   +---
@param inst Instance of object to check for type compatibility.
|   |   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSCheckTypeInst
|   |   +---(
|   |   +---typeinst
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +--- 
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---checkTypeInst
|   |   +---(
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---typeinst
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---the conversion of functions that are from MULTIPLY inherited classes.
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-typedef (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---*
|   |   +---_ptf_t
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-static (HAS STATE)
|   +--- 
|   +---inline
|   +--- 
|   +---_ptf_t
|   +---[ NEWLINE ]
|   +---_ptmf2ptf
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   |   +---OSMetaClassBase
|   |   |   +---::
|   |   |   +---*
|   |   |   +---func
|   |   |   +---)
|   |   +---(
|   |   |   +---void
|   |   |   +---)
|   |   +---)
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMemberFunctionCast
|   |   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   |   +---
@param type The type of pointer function desired.
|   |   +---
@param self The this pointer of the object whose function you wish to cache.
|   |   +---
@param func The pointer to member function itself, something like &Base::func.
|   |   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSMemberFunctionCast
|   |   +---(
|   |   +---cptrtype
|   |   +---,
|   |   +--- 
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---cptrtype
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---                                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---            
|   |   +---_ptmf2ptf
|   |   +---(
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---(
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---)
|   |   +---(
|   |   +---void
|   |   +---)
|   |   +---)
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---~
|   +---OSMetaClassBase
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Disable copy constructors of OSMetaClassBase based objects
|   |   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function operator =
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-void (HAS STATE)
|   +--- 
|   +---operator
|   +--- 
|   +---=
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMetaClassBase
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Primary implementation of the release mechanism.
|   |   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   |   +---
@param when When retainCount == when then call free(). 
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function getRetainCount
|   |   +---
@abstract How many times has this object been retained?
|   |   +---
@result Current retain count
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---int
|   +--- 
|   +---getRetainCount
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function retain
|   |   +---
@abstract Retain a reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---retain
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Release a reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function serialize
|   |   +---
@abstract 
|   |   +---
@discussion 
|   |   +---
@param s
|   |   +---
@result 
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---serialize
|   +---(
|   |   +---OSSerialize
|   |   +--- 
|   |   +---*
|   |   +---s
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +--- 
|   +---getMetaClass
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function isEqualTo
|   |   +---
@abstract Is this == anObj?
|   |   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   |   +---
@param anObj Object to compare 'this' to.
|   |   +---
@result true if the objects are equivalent, false otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---isEqualTo
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---anObj
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract Check to see if this object is or inherits from the given type.
|   |   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   |   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSSymbol of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSSymbol
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSString of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSString
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta const char * C String of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---char
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Helper inlines for runtime type preprocessor macros
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---[ NEWLINE ]
|   +---    
|   +---safeMetaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---me
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toType
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---bool
|   +---[ NEWLINE ]
|   +---    
|   +---checkTypeInst
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---typeinst
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRetain
|   |   +---
@abstract Retain a tagged reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRetain
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Virtual Padding
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase3
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase4
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase5
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase6
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase7
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---}
+---;
+--- 
+---[ NEWLINE ]
-=: COMPUTED VALUE :=-
SUCCESS: 0
VALUE: 0
-=: CPP CHANGES :=-
$CPP_HASH{OSCheckTypeInst} => 
    OSMetaClassBase::checkTypeInst(inst, typeinst)
$CPP_HASH{OSDynamicCast} =>        
    ((type *) OSMetaClassBase::safeMetaCast((inst),  (type::metaClass)))
$CPP_HASH{OSMemberFunctionCast} =>                        
    (cptrtype) OSMetaClassBase::                                        
            _ptmf2ptf(self, (void (OSMetaClassBase::*)(void)) func)
$CPP_HASH{OSTypeAlloc} =>        ((type *) ((type::metaClass)->alloc()))
$CPP_HASH{OSTypeID} =>        (type::metaClass)
$CPP_HASH{OSTypeIDInst} =>        ((typeinst)->getMetaClass())
$CPP_ARG_HASH{OSCheckTypeInst} => typeinst, inst
$CPP_ARG_HASH{OSDynamicCast} => type, inst
$CPP_ARG_HASH{OSMemberFunctionCast} => cptrtype, self, func
$CPP_ARG_HASH{OSTypeAlloc} => type
$CPP_ARG_HASH{OSTypeID} => type
$CPP_ARG_HASH{OSTypeIDInst} => typeinst
-=: FOUND MATCH :=-
1
-=: NAMED OBJECTS :=-
TREE COUNT: 0
INDEX GROUP: 
IS BLOCK: 
OBJECT TYPE: HeaderDoc::Header
NAME: class 4
APIUID: //test_ref/doc/header/class_4.test
ABSTRACT: ""
DISCUSSION: "<p></p>"
UPDATED: ""
COPYRIGHT: ""
HTMLMETA: ""
PRIVATEDECLARATION: ""
GROUP: ""
INDEXGROUP: ""
THROWS: ""
XMLTHROWS: ""
UPDATED: ""
LINKAGESTATE: ""
ACCESSCONTROL: ""
AVAILABILITY: ""
LINKUID: ""
ORIGCLASS: ""
ISDEFINE: ""
ISTEMPLATE: ""
VALUE: "UNKNOWN"
RETURNTYPE: ""
LINENUM: ""
CLASS: "HeaderDoc::Header"
MASTERENUM: ""
APIREFSETUPDONE: "1"
TPCDONE: ""
NOREGISTERUID: ""
SUPPRESSCHILDREN: ""
NAMELINE_DISCUSSION: ""
HIDEDOC: ""
HIDESINGLETONS: ""
HIDECONTENTS: ""
MAINOBJECT: ""
LIST ATTRIBUTES: 
SHORT ATTRIBUTES: <p></p>
LONG ATTRIBUTES: <p></p>
    TREE COUNT: 1
    INDEX GROUP: 
    IS BLOCK: 
    OBJECT TYPE: HeaderDoc::CPPClass
    NAME: OSMetaClassBase
    APIUID: 
    ABSTRACT: ""
    DISCUSSION: "<p>OSMetaClassBase "
    UPDATED: ""
    COPYRIGHT: ""
    HTMLMETA: ""
    PRIVATEDECLARATION: ""
    GROUP: ""
    INDEXGROUP: ""
    THROWS: ""
    XMLTHROWS: ""
    UPDATED: ""
    LINKAGESTATE: ""
    ACCESSCONTROL: ""
    AVAILABILITY: ""
    LINKUID: ""
    ORIGCLASS: ""
    ISDEFINE: ""
    ISTEMPLATE: ""
    VALUE: "UNKNOWN"
    RETURNTYPE: ""
    LINENUM: ""
    CLASS: "HeaderDoc::CPPClass"
    MASTERENUM: ""
    APIREFSETUPDONE: "1"
    TPCDONE: ""
    NOREGISTERUID: ""
    SUPPRESSCHILDREN: "1"
    NAMELINE_DISCUSSION: ""
    HIDEDOC: ""
    HIDESINGLETONS: ""
    HIDECONTENTS: ""
    MAINOBJECT: ""
    LIST ATTRIBUTES: 
    SHORT ATTRIBUTES: <p><b>Declared In:</b> <a href="../../index.html" target="_top">class 4</a><br>
</p>
    LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _ptmf2ptf
        APIUID: //test_ref/cpp/clm/OSMetaClassBase/_ptmf2ptf/inline_ptf_t/(constOSMetaClassBase*,void)
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " static inline _ptf_t"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: 
            TYPE:  void
            APIUID: //test_ref/cpp/internal_temporary_object/OSMetaClassBase
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: OSMetaClassBase
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/OSMetaClassBase//()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "protected"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: ~OSMetaClassBase
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/~OSMetaClassBase//()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "protected"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual "
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: operator =
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/operator%3D/void/(OSMetaClassBase%26)
        ABSTRACT: "<p>Disable implicit copy constructor by making private
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: "     void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: OSMetaClassBase &
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference to source object that isn't allowed to be copied"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: OSMetaClassBase
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/OSMetaClassBase//(OSMetaClassBase%26)
        ABSTRACT: "<p>Disable implicit copy constructor by making private
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: OSMetaClassBase &
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference to source object that isn't allowed to be copied"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: release
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/release/void/(int)
        ABSTRACT: "<p>Primary implementation of the release mechanism.
"
        DISCUSSION: "<p>If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: int
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>When retainCount == when then call free()."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: getRetainCount
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/getRetainCount/int/()
        ABSTRACT: "<p>How many times has this object been retained?
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual int"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: retain
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/retain/void/()
        ABSTRACT: "<p>Retain a reference in this object.
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: release
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/release/void/()
        ABSTRACT: "<p>Release a reference to this object
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: serialize
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/serialize/bool/(OSSerialize*)
        ABSTRACT: ""
        DISCUSSION: "
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: s
            TYPE: OSSerialize *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: s
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: " "
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: getMetaClass
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/getMetaClass/constOSMetaClass*/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual const OSMetaClass *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: isEqualTo
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/isEqualTo/bool/(constOSMetaClassBase*)
        ABSTRACT: "<p>Is this == anObj?
"
        DISCUSSION: "<p>OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: anObj
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: anObj
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Object to compare 'this' to."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSMetaClass*)
        ABSTRACT: "<p>Check to see if this object is or inherits from the given type.
"
        DISCUSSION: "<p>This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSMetaClass *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Pointer to a constant OSMetaClass for the desired target type."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSSymbol*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSSymbol *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>OSSymbol of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSString*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSString *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>OSString of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constchar*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const char *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>const char * C String of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: safeMetaCast
        APIUID: //test_ref/cpp/clm/OSMetaClassBase/safeMetaCast/OSMetaClassBase*/(constOSMetaClassBase*,constOSMetaClass*)
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " static OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: me
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toType
            TYPE: const OSMetaClass *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: checkTypeInst
        APIUID: //test_ref/cpp/clm/OSMetaClassBase/checkTypeInst/bool/(constOSMetaClassBase*,constOSMetaClassBase*)
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " static bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRetain
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRetain/void/(constvoid*)
        ABSTRACT: "<p>Retain a tagged reference in this object.
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRelease
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRelease/void/(constvoid*)
        ABSTRACT: "<p>Release a tagged reference to this object
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRelease
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRelease/void/(constvoid*,constint)
        ABSTRACT: "<p>Release a tagged reference to this object and free if retainCount == when on entry
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "protected"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: const int
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase3
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase3/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase4
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase4/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase5
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase5/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase6
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase6/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase7
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase7/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Typedef
        NAME: _ptf_t
        APIUID: //test_ref/cpp/tdef/OSMetaClassBase/_ptf_t
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::Typedef"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeAlloc
        APIUID: //test_ref/cpp/macro/OSTypeAlloc
        ABSTRACT: "<p>Allocate an instance of the desired object.
"
        DISCUSSION: "<p>The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Name of the desired type to be created."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeID
        APIUID: //test_ref/cpp/macro/OSTypeID
        ABSTRACT: "<p>Given the name of a class return it's typeID
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Name of the desired type, eg. OSObject."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeIDInst
        APIUID: //test_ref/cpp/macro/OSTypeIDInst
        ABSTRACT: "<p>Given a pointer to an object return it's typeID
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>An instance of an OSObject subclass."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSDynamicCast
        APIUID: //test_ref/cpp/macro/OSDynamicCast
        ABSTRACT: "<p>Roughly analogous to (type *) inst, but check if valid first.
"
        DISCUSSION: "<p>OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Pointer to object that you wish to attempt to type cast.  May be 0."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSCheckTypeInst
        APIUID: //test_ref/cpp/macro/OSCheckTypeInst
        ABSTRACT: "<p>Is the target object a subclass of the reference object?
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference instance of an object, desired type."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Instance of object to check for type compatibility."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSMemberFunctionCast
        APIUID: //test_ref/cpp/macro/OSMemberFunctionCast
        ABSTRACT: "<p>Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: cptrtype
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: func
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The type of pointer function desired."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The this pointer of the object whose function you wish to cache."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: func
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The pointer to member function itself, something like &Base::func."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
-=: NAMED OBJECT PARSE TREES :=-
OBJECT: OSMetaClassBase (HeaderDoc::CPPClass)
+---class
+--- 
+---OSMetaClassBase
+---[ NEWLINE ]
+---{
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeAlloc
|   |   +---
@abstract Allocate an instance of the desired object.
|   |   +---
@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
|   |   +---
@param type Name of the desired type to be created.
|   |   +---
@result 'this' if object cas been successfully created.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeAlloc
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---alloc
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeID
|   |   +---
@abstract Given the name of a class return it's typeID
|   |   +---
@param type Name of the desired type, eg. OSObject.
|   |   +---
@result A unique Type ID for the class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeID
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeIDInst
|   |   +---
@abstract Given a pointer to an object return it's typeID
|   |   +---
@param typeinst An instance of an OSObject subclass.
|   |   +---
@result The typeID, ie. OSMetaClass *.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeIDInst
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---getMetaClass
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSDynamicCast
|   |   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   |   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   |   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   |   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   |   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSDynamicCast
|   |   +---(
|   |   +---type
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +---        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---safeMetaCast
|   |   +---(
|   |   +---(
|   |   +---inst
|   |   +---)
|   |   +---,
|   |   +---  
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSCheckTypeInst
|   |   +---
@abstract Is the target object a subclass of the reference object?
|   |   +---
@param typeinst Reference instance of an object, desired type.
|   |   +---
@param inst Instance of object to check for type compatibility.
|   |   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSCheckTypeInst
|   |   +---(
|   |   +---typeinst
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +--- 
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---checkTypeInst
|   |   +---(
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---typeinst
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---the conversion of functions that are from MULTIPLY inherited classes.
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-typedef (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---*
|   |   +---_ptf_t
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-static (HAS STATE)
|   +--- 
|   +---inline
|   +--- 
|   +---_ptf_t
|   +---[ NEWLINE ]
|   +---_ptmf2ptf
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   |   +---OSMetaClassBase
|   |   |   +---::
|   |   |   +---*
|   |   |   +---func
|   |   |   +---)
|   |   +---(
|   |   |   +---void
|   |   |   +---)
|   |   +---)
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMemberFunctionCast
|   |   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   |   +---
@param type The type of pointer function desired.
|   |   +---
@param self The this pointer of the object whose function you wish to cache.
|   |   +---
@param func The pointer to member function itself, something like &Base::func.
|   |   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSMemberFunctionCast
|   |   +---(
|   |   +---cptrtype
|   |   +---,
|   |   +--- 
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---cptrtype
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---                                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---            
|   |   +---_ptmf2ptf
|   |   +---(
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---(
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---)
|   |   +---(
|   |   +---void
|   |   +---)
|   |   +---)
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---~
|   +---OSMetaClassBase
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Disable copy constructors of OSMetaClassBase based objects
|   |   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function operator =
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-void (HAS STATE)
|   +--- 
|   +---operator
|   +--- 
|   +---=
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMetaClassBase
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Primary implementation of the release mechanism.
|   |   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   |   +---
@param when When retainCount == when then call free(). 
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function getRetainCount
|   |   +---
@abstract How many times has this object been retained?
|   |   +---
@result Current retain count
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---int
|   +--- 
|   +---getRetainCount
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function retain
|   |   +---
@abstract Retain a reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---retain
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Release a reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function serialize
|   |   +---
@abstract 
|   |   +---
@discussion 
|   |   +---
@param s
|   |   +---
@result 
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---serialize
|   +---(
|   |   +---OSSerialize
|   |   +--- 
|   |   +---*
|   |   +---s
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +--- 
|   +---getMetaClass
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function isEqualTo
|   |   +---
@abstract Is this == anObj?
|   |   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   |   +---
@param anObj Object to compare 'this' to.
|   |   +---
@result true if the objects are equivalent, false otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---isEqualTo
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---anObj
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract Check to see if this object is or inherits from the given type.
|   |   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   |   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSSymbol of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSSymbol
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSString of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSString
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta const char * C String of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---char
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Helper inlines for runtime type preprocessor macros
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---[ NEWLINE ]
|   +---    
|   +---safeMetaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---me
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toType
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---bool
|   +---[ NEWLINE ]
|   +---    
|   +---checkTypeInst
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---typeinst
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRetain
|   |   +---
@abstract Retain a tagged reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRetain
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Virtual Padding
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase3
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase4
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase5
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase6
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase7
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---}
+---;
+--- 
+---[ NEWLINE ]
END OF OBJECT


OBJECT: _ptmf2ptf (HeaderDoc::Function)
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: ~OSMetaClassBase (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: operator = (HeaderDoc::Function)
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: getRetainCount (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: retain (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: serialize (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: getMetaClass (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: isEqualTo (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: safeMetaCast (HeaderDoc::Function)
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: checkTypeInst (HeaderDoc::Function)
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRetain (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase3 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase4 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase5 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase6 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase7 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _ptf_t (HeaderDoc::Typedef)
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeAlloc (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeAlloc
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---(
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +----
|   +--->
|   +---alloc
|   +---(
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeID
|   +---
@abstract Given the name of a class return it's typeID
|   +---
@param type Name of the desired type, eg. OSObject.
|   +---
@result A unique Type ID for the class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeID
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeIDInst
|   +---
@abstract Given a pointer to an object return it's typeID
|   +---
@param typeinst An instance of an OSObject subclass.
|   +---
@result The typeID, ie. OSMetaClass *.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeID (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeID
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeIDInst
|   +---
@abstract Given a pointer to an object return it's typeID
|   +---
@param typeinst An instance of an OSObject subclass.
|   +---
@result The typeID, ie. OSMetaClass *.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeIDInst (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSDynamicCast (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSCheckTypeInst (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMemberFunctionCast (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT



-=: HTML OUTPUT OF PARSE TREES :=-
OBJECT: OSMetaClassBase (HeaderDoc::CPPClass)
	<span class="keyword">class</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> { 
	    <span class="keyword">public</span>: <span class="comment">/*! @function OSTypeAlloc
	@abstract Allocate an instance of the desired object.
	@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
	@param type Name of the desired type to be created.
	@result 'this' if object cas been successfully created.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeAlloc //test_ref/cpp/tdef/OSTypeAlloc //test_ref/cpp/tag/OSTypeAlloc //test_ref/cpp/econst/OSTypeAlloc //test_ref/cpp/struct/OSTypeAlloc //test_ref/cpp/data/OSTypeAlloc //test_ref/cpp/clconst/OSTypeAlloc //test_ref/cpp/intf/OSTypeAlloc //test_ref/cpp/instm/OSTypeAlloc //test_ref/cpp/clm/OSTypeAlloc //test_ref/cpp/intfcm/OSTypeAlloc //test_ref/cpp/intfm/OSTypeAlloc //test_ref/cpp/func/OSTypeAlloc //test_ref/cpp/ftmplt/OSTypeAlloc //test_ref/cpp/defn/OSTypeAlloc //test_ref/cpp/macro/OSTypeAlloc //test_ref/doc/com/intfm/OSTypeAlloc" --><span class="preprocessor">OSTypeAlloc</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/alloc //test_ref/cpp/tdef/alloc //test_ref/cpp/tag/alloc //test_ref/cpp/econst/alloc //test_ref/cpp/struct/alloc //test_ref/cpp/data/alloc //test_ref/cpp/clconst/alloc //test_ref/cpp/intf/alloc //test_ref/cpp/instm/alloc //test_ref/cpp/clm/alloc //test_ref/cpp/intfcm/alloc //test_ref/cpp/intfm/alloc //test_ref/cpp/func/alloc //test_ref/cpp/ftmplt/alloc //test_ref/cpp/defn/alloc //test_ref/cpp/macro/alloc //test_ref/doc/com/intfm/alloc" --><span class="preprocessor">alloc</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSTypeID
	@abstract Given the name of a class return it's typeID
	@param type Name of the desired type, eg. OSObject.
	@result A unique Type ID for the class.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeID //test_ref/cpp/tdef/OSTypeID //test_ref/cpp/tag/OSTypeID //test_ref/cpp/econst/OSTypeID //test_ref/cpp/struct/OSTypeID //test_ref/cpp/data/OSTypeID //test_ref/cpp/clconst/OSTypeID //test_ref/cpp/intf/OSTypeID //test_ref/cpp/instm/OSTypeID //test_ref/cpp/clm/OSTypeID //test_ref/cpp/intfcm/OSTypeID //test_ref/cpp/intfm/OSTypeID //test_ref/cpp/func/OSTypeID //test_ref/cpp/ftmplt/OSTypeID //test_ref/cpp/defn/OSTypeID //test_ref/cpp/macro/OSTypeID //test_ref/doc/com/intfm/OSTypeID" --><span class="preprocessor">OSTypeID</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSTypeIDInst
	@abstract Given a pointer to an object return it's typeID
	@param typeinst An instance of an OSObject subclass.
	@result The typeID, ie. OSMetaClass *.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeIDInst //test_ref/cpp/tdef/OSTypeIDInst //test_ref/cpp/tag/OSTypeIDInst //test_ref/cpp/econst/OSTypeIDInst //test_ref/cpp/struct/OSTypeIDInst //test_ref/cpp/data/OSTypeIDInst //test_ref/cpp/clconst/OSTypeIDInst //test_ref/cpp/intf/OSTypeIDInst //test_ref/cpp/instm/OSTypeIDInst //test_ref/cpp/clm/OSTypeIDInst //test_ref/cpp/intfcm/OSTypeIDInst //test_ref/cpp/intfm/OSTypeIDInst //test_ref/cpp/func/OSTypeIDInst //test_ref/cpp/ftmplt/OSTypeIDInst //test_ref/cpp/defn/OSTypeIDInst //test_ref/cpp/macro/OSTypeIDInst //test_ref/doc/com/intfm/OSTypeIDInst" --><span class="preprocessor">OSTypeIDInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/getMetaClass //test_ref/cpp/tdef/getMetaClass //test_ref/cpp/tag/getMetaClass //test_ref/cpp/econst/getMetaClass //test_ref/cpp/struct/getMetaClass //test_ref/cpp/data/getMetaClass //test_ref/cpp/clconst/getMetaClass //test_ref/cpp/intf/getMetaClass //test_ref/cpp/instm/getMetaClass //test_ref/cpp/clm/getMetaClass //test_ref/cpp/intfcm/getMetaClass //test_ref/cpp/intfm/getMetaClass //test_ref/cpp/func/getMetaClass //test_ref/cpp/ftmplt/getMetaClass //test_ref/cpp/defn/getMetaClass //test_ref/cpp/macro/getMetaClass //test_ref/doc/com/intfm/getMetaClass" --><span class="preprocessor">getMetaClass</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSDynamicCast
	@abstract Roughly analogous to (type *) inst, but check if valid first.
	@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast&lt;T&gt; operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
	@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
	@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
	@result inst if object non-zero and it is of the desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSDynamicCast //test_ref/cpp/tdef/OSDynamicCast //test_ref/cpp/tag/OSDynamicCast //test_ref/cpp/econst/OSDynamicCast //test_ref/cpp/struct/OSDynamicCast //test_ref/cpp/data/OSDynamicCast //test_ref/cpp/clconst/OSDynamicCast //test_ref/cpp/intf/OSDynamicCast //test_ref/cpp/instm/OSDynamicCast //test_ref/cpp/clm/OSDynamicCast //test_ref/cpp/intfcm/OSDynamicCast //test_ref/cpp/intfm/OSDynamicCast //test_ref/cpp/func/OSDynamicCast //test_ref/cpp/ftmplt/OSDynamicCast //test_ref/cpp/defn/OSDynamicCast //test_ref/cpp/macro/OSDynamicCast //test_ref/doc/com/intfm/OSDynamicCast" --><span class="preprocessor">OSDynamicCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/safeMetaCast //test_ref/cpp/tdef/safeMetaCast //test_ref/cpp/tag/safeMetaCast //test_ref/cpp/econst/safeMetaCast //test_ref/cpp/struct/safeMetaCast //test_ref/cpp/data/safeMetaCast //test_ref/cpp/clconst/safeMetaCast //test_ref/cpp/intf/safeMetaCast //test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast //test_ref/doc/com/intfm/safeMetaCast" --><span class="preprocessor">safeMetaCast</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSCheckTypeInst
	@abstract Is the target object a subclass of the reference object?
	@param typeinst Reference instance of an object, desired type.
	@param inst Instance of object to check for type compatibility.
	@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSCheckTypeInst //test_ref/cpp/tdef/OSCheckTypeInst //test_ref/cpp/tag/OSCheckTypeInst //test_ref/cpp/econst/OSCheckTypeInst //test_ref/cpp/struct/OSCheckTypeInst //test_ref/cpp/data/OSCheckTypeInst //test_ref/cpp/clconst/OSCheckTypeInst //test_ref/cpp/intf/OSCheckTypeInst //test_ref/cpp/instm/OSCheckTypeInst //test_ref/cpp/clm/OSCheckTypeInst //test_ref/cpp/intfcm/OSCheckTypeInst //test_ref/cpp/intfm/OSCheckTypeInst //test_ref/cpp/func/OSCheckTypeInst //test_ref/cpp/ftmplt/OSCheckTypeInst //test_ref/cpp/defn/OSCheckTypeInst //test_ref/cpp/macro/OSCheckTypeInst //test_ref/doc/com/intfm/OSCheckTypeInst" --><span class="preprocessor">OSCheckTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/checkTypeInst //test_ref/cpp/tdef/checkTypeInst //test_ref/cpp/tag/checkTypeInst //test_ref/cpp/econst/checkTypeInst //test_ref/cpp/struct/checkTypeInst //test_ref/cpp/data/checkTypeInst //test_ref/cpp/clconst/checkTypeInst //test_ref/cpp/intf/checkTypeInst //test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst //test_ref/doc/com/intfm/checkTypeInst" --><span class="preprocessor">checkTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span>   
	    <span class="comment">// Arcane evil code interprets a C++ pointer to function as specified in the</span> 
	    <span class="comment">// -fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW</span> 
	    <span class="comment">// the conversion of functions that are from MULTIPLY inherited classes.</span>  
	    <span class="keyword">typedef</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> (<span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/_ptf_t //test_ref/cpp/clm/_ptf_t //test_ref/cpp/intfcm/_ptf_t //test_ref/cpp/intfm/_ptf_t //test_ref/cpp/func/_ptf_t //test_ref/cpp/ftmplt/_ptf_t //test_ref/cpp/defn/_ptf_t //test_ref/cpp/macro/_ptf_t" --><span class="function">_ptf_t</span><!-- /a -->)(
	        <span class="param">void</span>);  
	    <span class="keyword">static</span> <span class="keyword">inline</span> <!-- a logicalPath="//test_ref/cpp/cl/_ptf_t //test_ref/cpp/tdef/_ptf_t //test_ref/cpp/tag/_ptf_t //test_ref/cpp/econst/_ptf_t //test_ref/cpp/struct/_ptf_t //test_ref/cpp/clconst/_ptf_t //test_ref/cpp/intf/_ptf_t" --><span class="type">_ptf_t</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf" --><span class="function">_ptmf2ptf</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/self //test_ref/cpp/data/self" --><span class="var">self</span><!-- /a -->,
	        <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> (<!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a -->::<span class="type">*</span><span class="param">func</span>)(<!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a -->))   <span class="comment">/*! @function OSMemberFunctionCast
	@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
	@param type The type of pointer function desired.
	@param self The this pointer of the object whose function you wish to cache.
	@param func The pointer to member function itself, something like &amp;Base::func.
	@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMemberFunctionCast //test_ref/cpp/tdef/OSMemberFunctionCast //test_ref/cpp/tag/OSMemberFunctionCast //test_ref/cpp/econst/OSMemberFunctionCast //test_ref/cpp/struct/OSMemberFunctionCast //test_ref/cpp/data/OSMemberFunctionCast //test_ref/cpp/clconst/OSMemberFunctionCast //test_ref/cpp/intf/OSMemberFunctionCast //test_ref/cpp/instm/OSMemberFunctionCast //test_ref/cpp/clm/OSMemberFunctionCast //test_ref/cpp/intfcm/OSMemberFunctionCast //test_ref/cpp/intfm/OSMemberFunctionCast //test_ref/cpp/func/OSMemberFunctionCast //test_ref/cpp/ftmplt/OSMemberFunctionCast //test_ref/cpp/defn/OSMemberFunctionCast //test_ref/cpp/macro/OSMemberFunctionCast //test_ref/doc/com/intfm/OSMemberFunctionCast" --><span class="preprocessor">OSMemberFunctionCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <!-- a logicalPath="//test_ref/cpp/cl/_ptmf2ptf //test_ref/cpp/tdef/_ptmf2ptf //test_ref/cpp/tag/_ptmf2ptf //test_ref/cpp/econst/_ptmf2ptf //test_ref/cpp/struct/_ptmf2ptf //test_ref/cpp/data/_ptmf2ptf //test_ref/cpp/clconst/_ptmf2ptf //test_ref/cpp/intf/_ptmf2ptf //test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf //test_ref/doc/com/intfm/_ptmf2ptf" --><span class="preprocessor">_ptmf2ptf</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span>  
	    <span class="keyword">protected</span>: <!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> ~<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->();  
	    <span class="keyword">private</span>: <span class="comment">// Disable copy constructors of OSMetaClassBase based objects</span> 
	    <span class="comment">/*! @function operator =
	@abstract Disable implicit copy constructor by making private
	@param src Reference to source object that isn't allowed to be copied</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <span class="keyword">operator</span> =(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>);  
	    <span class="comment">/*! @function OSMetaClassBase
	@abstract Disable implicit copy constructor by making private
	@param src Reference to source object that isn't allowed to be copied</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>);  
	    <span class="keyword">public</span>: <span class="comment">/*! @function release
	@abstract Primary implementation of the release mechanism.
	@discussion  If $link retainCount &lt;= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. </span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <span class="param">when</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function getRetainCount
	@abstract How many times has this object been retained?
	@result Current retain count</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/getRetainCount //test_ref/cpp/clm/getRetainCount //test_ref/cpp/intfcm/getRetainCount //test_ref/cpp/intfm/getRetainCount //test_ref/cpp/func/getRetainCount //test_ref/cpp/ftmplt/getRetainCount //test_ref/cpp/defn/getRetainCount //test_ref/cpp/macro/getRetainCount" --><span class="function">getRetainCount</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function retain
	@abstract Retain a reference in this object.</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/retain //test_ref/cpp/clm/retain //test_ref/cpp/intfcm/retain //test_ref/cpp/intfm/retain //test_ref/cpp/func/retain //test_ref/cpp/ftmplt/retain //test_ref/cpp/defn/retain //test_ref/cpp/macro/retain" --><span class="function">retain</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
	    <span class="comment">/*! @function release
	@abstract Release a reference to this object</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function serialize
	@abstract 
	@discussion 
	@param s
	@result </span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/serialize //test_ref/cpp/clm/serialize //test_ref/cpp/intfcm/serialize //test_ref/cpp/intfm/serialize //test_ref/cpp/func/serialize //test_ref/cpp/ftmplt/serialize //test_ref/cpp/defn/serialize //test_ref/cpp/macro/serialize" --><span class="function">serialize</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSSerialize //test_ref/cpp/tdef/OSSerialize //test_ref/cpp/tag/OSSerialize //test_ref/cpp/econst/OSSerialize //test_ref/cpp/struct/OSSerialize //test_ref/cpp/clconst/OSSerialize //test_ref/cpp/intf/OSSerialize" --><span class="type">OSSerialize</span><!-- /a --> <span class="type">*</span><span class="param">s</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span> <!-- a logicalPath="//test_ref/cpp/econst/getMetaClass //test_ref/cpp/data/getMetaClass" --><span class="var">getMetaClass</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function isEqualTo
	@abstract Is this == anObj?
	@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
	@param anObj Object to compare 'this' to.
	@result true if the objects are equivalent, false otherwise.</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/isEqualTo //test_ref/cpp/clm/isEqualTo //test_ref/cpp/intfcm/isEqualTo //test_ref/cpp/intfm/isEqualTo //test_ref/cpp/func/isEqualTo //test_ref/cpp/ftmplt/isEqualTo //test_ref/cpp/defn/isEqualTo //test_ref/cpp/macro/isEqualTo" --><span class="function">isEqualTo</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/anObj //test_ref/cpp/data/anObj" --><span class="var">anObj</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract Check to see if this object is or inherits from the given type.
	@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
	@param toMeta Pointer to a constant OSMetaClass for the desired target type.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;   
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta OSSymbol of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSSymbol //test_ref/cpp/data/OSSymbol" --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta OSString of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSString //test_ref/cpp/data/OSString" --><span class="var">OSString</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta const char * C String of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/char //test_ref/cpp/data/char" --><span class="var">char</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">// Helper inlines for runtime type preprocessor macros</span> 
	    <span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span> <!-- a logicalPath="//test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast" --><span class="function">safeMetaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/me //test_ref/cpp/data/me" --><span class="var">me</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toType //test_ref/cpp/data/toType" --><span class="var">toType</span><!-- /a -->);  
	    <span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst" --><span class="function">checkTypeInst</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/inst //test_ref/cpp/data/inst" --><span class="var">inst</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/typeinst //test_ref/cpp/data/typeinst" --><span class="var">typeinst</span><!-- /a -->);  
	    <span class="keyword">public</span>:  <span class="comment">/*! @function taggedRetain
	@abstract Retain a tagged reference in this object.</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS: virtual void _RESERVEDOSMetaClassBase0();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRetain //test_ref/cpp/clm/taggedRetain //test_ref/cpp/intfcm/taggedRetain //test_ref/cpp/intfm/taggedRetain //test_ref/cpp/func/taggedRetain //test_ref/cpp/ftmplt/taggedRetain //test_ref/cpp/defn/taggedRetain //test_ref/cpp/macro/taggedRetain" --><span class="function">taggedRetain</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function taggedRelease
	@abstract Release a tagged reference to this object</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS:  virtual void _RESERVEDOSMetaClassBase1();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">protected</span>: <span class="comment">/*! @function taggedRelease
	@abstract Release a tagged reference to this object and free if retainCount == when on entry</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS:  virtual void _RESERVEDOSMetaClassBase2();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/int //test_ref/cpp/data/int" --><span class="var">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/econst/when //test_ref/cpp/data/when" --><span class="var">when</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">private</span>: <span class="comment">// Virtual Padding</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/func/_RESERVEDOSMetaClassBase3 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase3 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase3 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase3" --><span class="function">_RESERVEDOSMetaClassBase3</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/func/_RESERVEDOSMetaClassBase4 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase4 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase4 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase4" --><span class="function">_RESERVEDOSMetaClassBase4</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/func/_RESERVEDOSMetaClassBase5 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase5 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase5 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase5" --><span class="function">_RESERVEDOSMetaClassBase5</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/func/_RESERVEDOSMetaClassBase6 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase6 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase6 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase6" --><span class="function">_RESERVEDOSMetaClassBase6</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/func/_RESERVEDOSMetaClassBase7 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase7 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase7 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase7" --><span class="function">_RESERVEDOSMetaClassBase7</span><!-- /a -->(); 
	};  
END OF OBJECT


OBJECT: _ptmf2ptf (HeaderDoc::Function)
	<span class="keyword">static</span> <span class="keyword">inline</span> <!-- a logicalPath="//test_ref/cpp/cl/_ptf_t //test_ref/cpp/tdef/_ptf_t //test_ref/cpp/tag/_ptf_t //test_ref/cpp/econst/_ptf_t //test_ref/cpp/struct/_ptf_t //test_ref/cpp/clconst/_ptf_t //test_ref/cpp/intf/_ptf_t" --><span class="type">_ptf_t</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf" --><span class="function">_ptmf2ptf</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/self //test_ref/cpp/data/self" --><span class="var">self</span><!-- /a -->,
	    <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> (<!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a -->::<span class="type">*</span><span class="param">func</span>)(<!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a -->)) 
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(); 
END OF OBJECT


OBJECT: ~OSMetaClassBase (HeaderDoc::Function)
	<span class="keyword">virtual</span> ~<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(); 
END OF OBJECT


OBJECT: operator = (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <span class="keyword">operator</span> =(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>); 
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>); 
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <span class="param">when</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: getRetainCount (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/getRetainCount //test_ref/cpp/clm/getRetainCount //test_ref/cpp/intfcm/getRetainCount //test_ref/cpp/intfm/getRetainCount //test_ref/cpp/func/getRetainCount //test_ref/cpp/ftmplt/getRetainCount //test_ref/cpp/defn/getRetainCount //test_ref/cpp/macro/getRetainCount" --><span class="function">getRetainCount</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: retain (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/retain //test_ref/cpp/clm/retain //test_ref/cpp/intfcm/retain //test_ref/cpp/intfm/retain //test_ref/cpp/func/retain //test_ref/cpp/ftmplt/retain //test_ref/cpp/defn/retain //test_ref/cpp/macro/retain" --><span class="function">retain</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: serialize (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/serialize //test_ref/cpp/clm/serialize //test_ref/cpp/intfcm/serialize //test_ref/cpp/intfm/serialize //test_ref/cpp/func/serialize //test_ref/cpp/ftmplt/serialize //test_ref/cpp/defn/serialize //test_ref/cpp/macro/serialize" --><span class="function">serialize</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSSerialize //test_ref/cpp/tdef/OSSerialize //test_ref/cpp/tag/OSSerialize //test_ref/cpp/econst/OSSerialize //test_ref/cpp/struct/OSSerialize //test_ref/cpp/clconst/OSSerialize //test_ref/cpp/intf/OSSerialize" --><span class="type">OSSerialize</span><!-- /a --> <span class="type">*</span><span class="param">s</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: getMetaClass (HeaderDoc::Function)
	<span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span> <!-- a logicalPath="//test_ref/cpp/econst/getMetaClass //test_ref/cpp/data/getMetaClass" --><span class="var">getMetaClass</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: isEqualTo (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/isEqualTo //test_ref/cpp/clm/isEqualTo //test_ref/cpp/intfcm/isEqualTo //test_ref/cpp/intfm/isEqualTo //test_ref/cpp/func/isEqualTo //test_ref/cpp/ftmplt/isEqualTo //test_ref/cpp/defn/isEqualTo //test_ref/cpp/macro/isEqualTo" --><span class="function">isEqualTo</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/anObj //test_ref/cpp/data/anObj" --><span class="var">anObj</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSSymbol //test_ref/cpp/data/OSSymbol" --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSString //test_ref/cpp/data/OSString" --><span class="var">OSString</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/char //test_ref/cpp/data/char" --><span class="var">char</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: safeMetaCast (HeaderDoc::Function)
	<span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span> <!-- a logicalPath="//test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast" --><span class="function">safeMetaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/me //test_ref/cpp/data/me" --><span class="var">me</span><!-- /a -->,
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toType //test_ref/cpp/data/toType" --><span class="var">toType</span><!-- /a -->); 
END OF OBJECT


OBJECT: checkTypeInst (HeaderDoc::Function)
	<span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst" --><span class="function">checkTypeInst</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/inst //test_ref/cpp/data/inst" --><span class="var">inst</span><!-- /a -->,
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/typeinst //test_ref/cpp/data/typeinst" --><span class="var">typeinst</span><!-- /a -->); 
END OF OBJECT


OBJECT: taggedRetain (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRetain //test_ref/cpp/clm/taggedRetain //test_ref/cpp/intfcm/taggedRetain //test_ref/cpp/intfm/taggedRetain //test_ref/cpp/func/taggedRetain //test_ref/cpp/ftmplt/taggedRetain //test_ref/cpp/defn/taggedRetain //test_ref/cpp/macro/taggedRetain" --><span class="function">taggedRetain</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a -->,
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/int //test_ref/cpp/data/int" --><span class="var">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/econst/when //test_ref/cpp/data/when" --><span class="var">when</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase3 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/func/_RESERVEDOSMetaClassBase3 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase3 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase3 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase3" --><span class="function">_RESERVEDOSMetaClassBase3</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase4 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/func/_RESERVEDOSMetaClassBase4 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase4 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase4 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase4" --><span class="function">_RESERVEDOSMetaClassBase4</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase5 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/func/_RESERVEDOSMetaClassBase5 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase5 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase5 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase5" --><span class="function">_RESERVEDOSMetaClassBase5</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase6 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/func/_RESERVEDOSMetaClassBase6 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase6 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase6 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase6" --><span class="function">_RESERVEDOSMetaClassBase6</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase7 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/func/_RESERVEDOSMetaClassBase7 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase7 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase7 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase7" --><span class="function">_RESERVEDOSMetaClassBase7</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _ptf_t (HeaderDoc::Typedef)
	<span class="keyword">typedef</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> ( <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/_ptf_t //test_ref/cpp/clm/_ptf_t //test_ref/cpp/intfcm/_ptf_t //test_ref/cpp/intfm/_ptf_t //test_ref/cpp/func/_ptf_t //test_ref/cpp/ftmplt/_ptf_t //test_ref/cpp/defn/_ptf_t //test_ref/cpp/macro/_ptf_t" --><span class="function">_ptf_t</span><!-- /a -->)(
	    <span class="param">void</span>); 
END OF OBJECT


OBJECT: OSTypeAlloc (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeAlloc //test_ref/cpp/tdef/OSTypeAlloc //test_ref/cpp/tag/OSTypeAlloc //test_ref/cpp/econst/OSTypeAlloc //test_ref/cpp/struct/OSTypeAlloc //test_ref/cpp/data/OSTypeAlloc //test_ref/cpp/clconst/OSTypeAlloc //test_ref/cpp/intf/OSTypeAlloc //test_ref/cpp/instm/OSTypeAlloc //test_ref/cpp/clm/OSTypeAlloc //test_ref/cpp/intfcm/OSTypeAlloc //test_ref/cpp/intfm/OSTypeAlloc //test_ref/cpp/func/OSTypeAlloc //test_ref/cpp/ftmplt/OSTypeAlloc //test_ref/cpp/defn/OSTypeAlloc //test_ref/cpp/macro/OSTypeAlloc //test_ref/doc/com/intfm/OSTypeAlloc" --><span class="preprocessor">OSTypeAlloc</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/alloc //test_ref/cpp/tdef/alloc //test_ref/cpp/tag/alloc //test_ref/cpp/econst/alloc //test_ref/cpp/struct/alloc //test_ref/cpp/data/alloc //test_ref/cpp/clconst/alloc //test_ref/cpp/intf/alloc //test_ref/cpp/instm/alloc //test_ref/cpp/clm/alloc //test_ref/cpp/intfcm/alloc //test_ref/cpp/intfm/alloc //test_ref/cpp/func/alloc //test_ref/cpp/ftmplt/alloc //test_ref/cpp/defn/alloc //test_ref/cpp/macro/alloc //test_ref/doc/com/intfm/alloc" --><span class="preprocessor">alloc</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSTypeID (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeID //test_ref/cpp/tdef/OSTypeID //test_ref/cpp/tag/OSTypeID //test_ref/cpp/econst/OSTypeID //test_ref/cpp/struct/OSTypeID //test_ref/cpp/data/OSTypeID //test_ref/cpp/clconst/OSTypeID //test_ref/cpp/intf/OSTypeID //test_ref/cpp/instm/OSTypeID //test_ref/cpp/clm/OSTypeID //test_ref/cpp/intfcm/OSTypeID //test_ref/cpp/intfm/OSTypeID //test_ref/cpp/func/OSTypeID //test_ref/cpp/ftmplt/OSTypeID //test_ref/cpp/defn/OSTypeID //test_ref/cpp/macro/OSTypeID //test_ref/doc/com/intfm/OSTypeID" --><span class="preprocessor">OSTypeID</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSTypeIDInst (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeIDInst //test_ref/cpp/tdef/OSTypeIDInst //test_ref/cpp/tag/OSTypeIDInst //test_ref/cpp/econst/OSTypeIDInst //test_ref/cpp/struct/OSTypeIDInst //test_ref/cpp/data/OSTypeIDInst //test_ref/cpp/clconst/OSTypeIDInst //test_ref/cpp/intf/OSTypeIDInst //test_ref/cpp/instm/OSTypeIDInst //test_ref/cpp/clm/OSTypeIDInst //test_ref/cpp/intfcm/OSTypeIDInst //test_ref/cpp/intfm/OSTypeIDInst //test_ref/cpp/func/OSTypeIDInst //test_ref/cpp/ftmplt/OSTypeIDInst //test_ref/cpp/defn/OSTypeIDInst //test_ref/cpp/macro/OSTypeIDInst //test_ref/doc/com/intfm/OSTypeIDInst" --><span class="preprocessor">OSTypeIDInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/getMetaClass //test_ref/cpp/tdef/getMetaClass //test_ref/cpp/tag/getMetaClass //test_ref/cpp/econst/getMetaClass //test_ref/cpp/struct/getMetaClass //test_ref/cpp/data/getMetaClass //test_ref/cpp/clconst/getMetaClass //test_ref/cpp/intf/getMetaClass //test_ref/cpp/instm/getMetaClass //test_ref/cpp/clm/getMetaClass //test_ref/cpp/intfcm/getMetaClass //test_ref/cpp/intfm/getMetaClass //test_ref/cpp/func/getMetaClass //test_ref/cpp/ftmplt/getMetaClass //test_ref/cpp/defn/getMetaClass //test_ref/cpp/macro/getMetaClass //test_ref/doc/com/intfm/getMetaClass" --><span class="preprocessor">getMetaClass</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSDynamicCast (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSDynamicCast //test_ref/cpp/tdef/OSDynamicCast //test_ref/cpp/tag/OSDynamicCast //test_ref/cpp/econst/OSDynamicCast //test_ref/cpp/struct/OSDynamicCast //test_ref/cpp/data/OSDynamicCast //test_ref/cpp/clconst/OSDynamicCast //test_ref/cpp/intf/OSDynamicCast //test_ref/cpp/instm/OSDynamicCast //test_ref/cpp/clm/OSDynamicCast //test_ref/cpp/intfcm/OSDynamicCast //test_ref/cpp/intfm/OSDynamicCast //test_ref/cpp/func/OSDynamicCast //test_ref/cpp/ftmplt/OSDynamicCast //test_ref/cpp/defn/OSDynamicCast //test_ref/cpp/macro/OSDynamicCast //test_ref/doc/com/intfm/OSDynamicCast" --><span class="preprocessor">OSDynamicCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/safeMetaCast //test_ref/cpp/tdef/safeMetaCast //test_ref/cpp/tag/safeMetaCast //test_ref/cpp/econst/safeMetaCast //test_ref/cpp/struct/safeMetaCast //test_ref/cpp/data/safeMetaCast //test_ref/cpp/clconst/safeMetaCast //test_ref/cpp/intf/safeMetaCast //test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast //test_ref/doc/com/intfm/safeMetaCast" --><span class="preprocessor">safeMetaCast</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSCheckTypeInst (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSCheckTypeInst //test_ref/cpp/tdef/OSCheckTypeInst //test_ref/cpp/tag/OSCheckTypeInst //test_ref/cpp/econst/OSCheckTypeInst //test_ref/cpp/struct/OSCheckTypeInst //test_ref/cpp/data/OSCheckTypeInst //test_ref/cpp/clconst/OSCheckTypeInst //test_ref/cpp/intf/OSCheckTypeInst //test_ref/cpp/instm/OSCheckTypeInst //test_ref/cpp/clm/OSCheckTypeInst //test_ref/cpp/intfcm/OSCheckTypeInst //test_ref/cpp/intfm/OSCheckTypeInst //test_ref/cpp/func/OSCheckTypeInst //test_ref/cpp/ftmplt/OSCheckTypeInst //test_ref/cpp/defn/OSCheckTypeInst //test_ref/cpp/macro/OSCheckTypeInst //test_ref/doc/com/intfm/OSCheckTypeInst" --><span class="preprocessor">OSCheckTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/checkTypeInst //test_ref/cpp/tdef/checkTypeInst //test_ref/cpp/tag/checkTypeInst //test_ref/cpp/econst/checkTypeInst //test_ref/cpp/struct/checkTypeInst //test_ref/cpp/data/checkTypeInst //test_ref/cpp/clconst/checkTypeInst //test_ref/cpp/intf/checkTypeInst //test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst //test_ref/doc/com/intfm/checkTypeInst" --><span class="preprocessor">checkTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSMemberFunctionCast (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMemberFunctionCast //test_ref/cpp/tdef/OSMemberFunctionCast //test_ref/cpp/tag/OSMemberFunctionCast //test_ref/cpp/econst/OSMemberFunctionCast //test_ref/cpp/struct/OSMemberFunctionCast //test_ref/cpp/data/OSMemberFunctionCast //test_ref/cpp/clconst/OSMemberFunctionCast //test_ref/cpp/intf/OSMemberFunctionCast //test_ref/cpp/instm/OSMemberFunctionCast //test_ref/cpp/clm/OSMemberFunctionCast //test_ref/cpp/intfcm/OSMemberFunctionCast //test_ref/cpp/intfm/OSMemberFunctionCast //test_ref/cpp/func/OSMemberFunctionCast //test_ref/cpp/ftmplt/OSMemberFunctionCast //test_ref/cpp/defn/OSMemberFunctionCast //test_ref/cpp/macro/OSMemberFunctionCast //test_ref/doc/com/intfm/OSMemberFunctionCast" --><span class="preprocessor">OSMemberFunctionCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <!-- a logicalPath="//test_ref/cpp/cl/_ptmf2ptf //test_ref/cpp/tdef/_ptmf2ptf //test_ref/cpp/tag/_ptmf2ptf //test_ref/cpp/econst/_ptmf2ptf //test_ref/cpp/struct/_ptmf2ptf //test_ref/cpp/data/_ptmf2ptf //test_ref/cpp/clconst/_ptmf2ptf //test_ref/cpp/intf/_ptmf2ptf //test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf //test_ref/doc/com/intfm/_ptmf2ptf" --><span class="preprocessor">_ptmf2ptf</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT



_$35|testsuite/parser_tests/class_4.test$1|C$7|class 4$393396|-=: TOP LEVEL COMMENT PARSE VALUES :=-
inHeader: 0
inClass: 0
inInterface: 0
inCPPHeader: 0
inOCCHeader: 0
inPerlScript: 0
inShellScript: 0
inPHPScript: 0
inJavaSource: 0
inFunctionGroup: 0
inGroup: 0
inFunction: 0
inPDefine: 0
inTypedef: 0
inUnion: 0
inStruct: 0
inConstant: 0
inVar: 0
inEnum: 0
inMethod: 0
inAvailabilityMacro: 0
inUnknown: 1
classType: unknown
inputCounter: 0
blockOffset: 0
fullpath: /test_suite_bogus_path/class_4.test
-=: BLOCKPARSE PARSER STATE KEYS :=-
$parserState->{FULLPATH} => /test_suite_bogus_path/class_4.test
$parserState->{ISFORWARDDECLARATION} => 0
$parserState->{NEXTTOKENNOCPP} => 0
$parserState->{availability} => 
$parserState->{backslashcount} => 0
$parserState->{basetype} => 
$parserState->{bracePending} => 0
$parserState->{callbackIsTypedef} => 0
$parserState->{callbackName} => 
$parserState->{callbackNamePending} => -1
$parserState->{categoryClass} => 
$parserState->{classNameFound} => 1
$parserState->{classtype} => class
$parserState->{forceClassDone} => 1
$parserState->{freezeStack} => ARRAY(OBJID)
$parserState->{freezereturn} => 1
$parserState->{frozensodname} => 
$parserState->{functionReturnsCallback} => 0
$parserState->{hollow} => HeaderDoc::ParseTree=HASH(OBJID)
$parserState->{inBrackets} => 0
$parserState->{inChar} => 0
$parserState->{inClass} => 1
$parserState->{inComment} => 0
$parserState->{inInlineComment} => 0
$parserState->{inMacro} => 0
$parserState->{inMacroLine} => 0
$parserState->{inOperator} => 0
$parserState->{inPrivateParamTypes} => 0
$parserState->{inString} => 0
$parserState->{inTemplate} => 0
$parserState->{initbsCount} => 0
$parserState->{inputCounter} => 142
$parserState->{kr_c_function} => 0
$parserState->{kr_c_name} => 
$parserState->{lang} => C
$parserState->{lastTreeNode} => HeaderDoc::ParseTree=HASH(OBJID)
$parserState->{lastsymbol} => ;
$parserState->{macroNoTrunc} => 1
$parserState->{name} => 
$parserState->{namePending} => 0
$parserState->{noInsert} => 0
$parserState->{occmethod} => 0
$parserState->{occmethodname} => 
$parserState->{occparmlabelfound} => 2
$parserState->{onlyComments} => 0
$parserState->{parsedParamList} => ARRAY(OBJID)
$parserState->{parsedParamParse} => 1
$parserState->{posstypes} => 
$parserState->{posstypesPending} => 0
$parserState->{pplStack} => ARRAY(OBJID)
$parserState->{preEqualsSymbol} => 
$parserState->{preTemplateSymbol} => 
$parserState->{preclasssodtype} => class
$parserState->{returntype} => class OSMetaClassBase  
$parserState->{seenBraces} => 0
$parserState->{seenMacroPart} => 0
$parserState->{seenTilde} => 0
$parserState->{simpleTDcontents} => 
$parserState->{simpleTypedef} => 0
$parserState->{sodclass} => class
$parserState->{sodname} => OSMetaClassBase
$parserState->{sodtype} => 
$parserState->{sodtypeclasstoken} => class
$parserState->{stackFrozen} => 0
$parserState->{startOfDec} => 1
$parserState->{storeDec} => 
$parserState->{temponlyComments} => 0
$parserState->{treePopTwo} => 0
$parserState->{typestring} => OSMetaClassBase
$parserState->{value} => 
$parserState->{valuepending} => 0
-=: BLOCKPARSE RETURN VALUES :=-
newcount: 142
typelist: class
namelist: OSMetaClassBase
posstypes: 
value: 
returntype: 
pridec: 
simpleTDcontents: 
bpavail: 
blockOffset: 79
conformsToList: 
functionContents: 
extendsClass: 
implementsClass: 
-=: LIST OF PARSED PARAMETERS :=-
-=: DUMP OF PARSE TREE :=-
+---class
+--- 
+---OSMetaClassBase
+---[ NEWLINE ]
+---{
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeAlloc
|   |   +---
@abstract Allocate an instance of the desired object.
|   |   +---
@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
|   |   +---
@param type Name of the desired type to be created.
|   |   +---
@result 'this' if object cas been successfully created.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeAlloc
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---alloc
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeID
|   |   +---
@abstract Given the name of a class return it's typeID
|   |   +---
@param type Name of the desired type, eg. OSObject.
|   |   +---
@result A unique Type ID for the class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeID
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeIDInst
|   |   +---
@abstract Given a pointer to an object return it's typeID
|   |   +---
@param typeinst An instance of an OSObject subclass.
|   |   +---
@result The typeID, ie. OSMetaClass *.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeIDInst
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---getMetaClass
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSDynamicCast
|   |   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   |   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   |   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   |   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   |   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSDynamicCast
|   |   +---(
|   |   +---type
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +---        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---safeMetaCast
|   |   +---(
|   |   +---(
|   |   +---inst
|   |   +---)
|   |   +---,
|   |   +---  
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSCheckTypeInst
|   |   +---
@abstract Is the target object a subclass of the reference object?
|   |   +---
@param typeinst Reference instance of an object, desired type.
|   |   +---
@param inst Instance of object to check for type compatibility.
|   |   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSCheckTypeInst
|   |   +---(
|   |   +---typeinst
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +--- 
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---checkTypeInst
|   |   +---(
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---typeinst
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---the conversion of functions that are from MULTIPLY inherited classes.
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-typedef (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---*
|   |   +---_ptf_t
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-static (HAS STATE)
|   +--- 
|   +---inline
|   +--- 
|   +---_ptf_t
|   +---[ NEWLINE ]
|   +---_ptmf2ptf
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   |   +---OSMetaClassBase
|   |   |   +---::
|   |   |   +---*
|   |   |   +---func
|   |   |   +---)
|   |   +---(
|   |   |   +---void
|   |   |   +---)
|   |   +---)
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMemberFunctionCast
|   |   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   |   +---
@param type The type of pointer function desired.
|   |   +---
@param self The this pointer of the object whose function you wish to cache.
|   |   +---
@param func The pointer to member function itself, something like &Base::func.
|   |   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSMemberFunctionCast
|   |   +---(
|   |   +---cptrtype
|   |   +---,
|   |   +--- 
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---cptrtype
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---                                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---            
|   |   +---_ptmf2ptf
|   |   +---(
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---(
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---)
|   |   +---(
|   |   +---void
|   |   +---)
|   |   +---)
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---~
|   +---OSMetaClassBase
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Disable copy constructors of OSMetaClassBase based objects
|   |   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function operator =
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-void (HAS STATE)
|   +--- 
|   +---operator
|   +--- 
|   +---=
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMetaClassBase
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Primary implementation of the release mechanism.
|   |   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   |   +---
@param when When retainCount == when then call free(). 
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function getRetainCount
|   |   +---
@abstract How many times has this object been retained?
|   |   +---
@result Current retain count
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---int
|   +--- 
|   +---getRetainCount
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function retain
|   |   +---
@abstract Retain a reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---retain
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Release a reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function serialize
|   |   +---
@abstract 
|   |   +---
@discussion 
|   |   +---
@param s
|   |   +---
@result 
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---serialize
|   +---(
|   |   +---OSSerialize
|   |   +--- 
|   |   +---*
|   |   +---s
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +--- 
|   +---getMetaClass
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function isEqualTo
|   |   +---
@abstract Is this == anObj?
|   |   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   |   +---
@param anObj Object to compare 'this' to.
|   |   +---
@result true if the objects are equivalent, false otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---isEqualTo
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---anObj
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract Check to see if this object is or inherits from the given type.
|   |   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   |   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSSymbol of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSSymbol
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSString of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSString
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta const char * C String of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---char
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Helper inlines for runtime type preprocessor macros
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---[ NEWLINE ]
|   +---    
|   +---safeMetaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---me
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toType
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---bool
|   +---[ NEWLINE ]
|   +---    
|   +---checkTypeInst
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---typeinst
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRetain
|   |   +---
@abstract Retain a tagged reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRetain
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Virtual Padding
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase3
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase4
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase5
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase6
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase7
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---}
+---;
+--- 
+---[ NEWLINE ]
-=: COMPUTED VALUE :=-
SUCCESS: 0
VALUE: 0
-=: CPP CHANGES :=-
$CPP_HASH{OSCheckTypeInst} => 
    OSMetaClassBase::checkTypeInst(inst, typeinst)
$CPP_HASH{OSDynamicCast} =>        
    ((type *) OSMetaClassBase::safeMetaCast((inst),  (type::metaClass)))
$CPP_HASH{OSMemberFunctionCast} =>                        
    (cptrtype) OSMetaClassBase::                                        
            _ptmf2ptf(self, (void (OSMetaClassBase::*)(void)) func)
$CPP_HASH{OSTypeAlloc} =>        ((type *) ((type::metaClass)->alloc()))
$CPP_HASH{OSTypeID} =>        (type::metaClass)
$CPP_HASH{OSTypeIDInst} =>        ((typeinst)->getMetaClass())
$CPP_ARG_HASH{OSCheckTypeInst} => typeinst, inst
$CPP_ARG_HASH{OSDynamicCast} => type, inst
$CPP_ARG_HASH{OSMemberFunctionCast} => cptrtype, self, func
$CPP_ARG_HASH{OSTypeAlloc} => type
$CPP_ARG_HASH{OSTypeID} => type
$CPP_ARG_HASH{OSTypeIDInst} => typeinst
-=: FOUND MATCH :=-
1
-=: NAMED OBJECTS :=-
TREE COUNT: 0
INDEX GROUP: 
IS BLOCK: 
OBJECT TYPE: HeaderDoc::Header
NAME: class 4
APIUID: //test_ref/doc/header/class_4.test
ABSTRACT: ""
DISCUSSION: "<p></p>"
UPDATED: ""
COPYRIGHT: ""
HTMLMETA: ""
PRIVATEDECLARATION: ""
GROUP: ""
INDEXGROUP: ""
THROWS: ""
XMLTHROWS: ""
UPDATED: ""
LINKAGESTATE: ""
ACCESSCONTROL: ""
AVAILABILITY: ""
LINKUID: ""
ORIGCLASS: ""
ISDEFINE: ""
ISTEMPLATE: ""
VALUE: "UNKNOWN"
RETURNTYPE: ""
LINENUM: ""
CLASS: "HeaderDoc::Header"
MASTERENUM: ""
APIREFSETUPDONE: "1"
TPCDONE: ""
NOREGISTERUID: ""
SUPPRESSCHILDREN: ""
NAMELINE_DISCUSSION: ""
HIDEDOC: ""
HIDESINGLETONS: ""
HIDECONTENTS: ""
MAINOBJECT: ""
LIST ATTRIBUTES: 
SHORT ATTRIBUTES: <p></p>
LONG ATTRIBUTES: <p></p>
    TREE COUNT: 1
    INDEX GROUP: 
    IS BLOCK: 
    OBJECT TYPE: HeaderDoc::CPPClass
    NAME: OSMetaClassBase
    APIUID: 
    ABSTRACT: ""
    DISCUSSION: "<p>OSMetaClassBase "
    UPDATED: ""
    COPYRIGHT: ""
    HTMLMETA: ""
    PRIVATEDECLARATION: ""
    GROUP: ""
    INDEXGROUP: ""
    THROWS: ""
    XMLTHROWS: ""
    UPDATED: ""
    LINKAGESTATE: ""
    ACCESSCONTROL: ""
    AVAILABILITY: ""
    LINKUID: ""
    ORIGCLASS: ""
    ISDEFINE: ""
    ISTEMPLATE: ""
    VALUE: "UNKNOWN"
    RETURNTYPE: ""
    LINENUM: ""
    CLASS: "HeaderDoc::CPPClass"
    MASTERENUM: ""
    APIREFSETUPDONE: "1"
    TPCDONE: ""
    NOREGISTERUID: ""
    SUPPRESSCHILDREN: "1"
    NAMELINE_DISCUSSION: ""
    HIDEDOC: ""
    HIDESINGLETONS: ""
    HIDECONTENTS: ""
    MAINOBJECT: ""
    LIST ATTRIBUTES: 
    SHORT ATTRIBUTES: <p><b>Declared In:</b> <a href="../../index.html" target="_top">class 4</a><br>
</p>
    LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: operator =
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/operator%3D/void/(OSMetaClassBase%26)
        ABSTRACT: "<p>Disable implicit copy constructor by making private
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: "     void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: OSMetaClassBase &
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference to source object that isn't allowed to be copied"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: OSMetaClassBase
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/OSMetaClassBase//(OSMetaClassBase%26)
        ABSTRACT: "<p>Disable implicit copy constructor by making private
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: OSMetaClassBase &
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference to source object that isn't allowed to be copied"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: release
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/release/void/(int)
        ABSTRACT: "<p>Primary implementation of the release mechanism.
"
        DISCUSSION: "<p>If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: int
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>When retainCount == when then call free()."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: getRetainCount
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/getRetainCount/int/()
        ABSTRACT: "<p>How many times has this object been retained?
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual int"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: retain
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/retain/void/()
        ABSTRACT: "<p>Retain a reference in this object.
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: release
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/release/void/()
        ABSTRACT: "<p>Release a reference to this object
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: serialize
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/serialize/bool/(OSSerialize*)
        ABSTRACT: ""
        DISCUSSION: "
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: s
            TYPE: OSSerialize *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: s
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: " "
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: isEqualTo
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/isEqualTo/bool/(constOSMetaClassBase*)
        ABSTRACT: "<p>Is this == anObj?
"
        DISCUSSION: "<p>OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: anObj
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: anObj
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Object to compare 'this' to."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSMetaClass*)
        ABSTRACT: "<p>Check to see if this object is or inherits from the given type.
"
        DISCUSSION: "<p>This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSMetaClass *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Pointer to a constant OSMetaClass for the desired target type."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSSymbol*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSSymbol *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>OSSymbol of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSString*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSString *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>OSString of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constchar*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const char *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>const char * C String of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRetain
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRetain/void/(constvoid*)
        ABSTRACT: "<p>Retain a tagged reference in this object.
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRelease
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRelease/void/(constvoid*)
        ABSTRACT: "<p>Release a tagged reference to this object
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRelease
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRelease/void/(constvoid*,constint)
        ABSTRACT: "<p>Release a tagged reference to this object and free if retainCount == when on entry
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "protected"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: const int
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeAlloc
        APIUID: //test_ref/cpp/macro/OSTypeAlloc
        ABSTRACT: "<p>Allocate an instance of the desired object.
"
        DISCUSSION: "<p>The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Name of the desired type to be created."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeID
        APIUID: //test_ref/cpp/macro/OSTypeID
        ABSTRACT: "<p>Given the name of a class return it's typeID
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Name of the desired type, eg. OSObject."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeIDInst
        APIUID: //test_ref/cpp/macro/OSTypeIDInst
        ABSTRACT: "<p>Given a pointer to an object return it's typeID
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>An instance of an OSObject subclass."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSDynamicCast
        APIUID: //test_ref/cpp/macro/OSDynamicCast
        ABSTRACT: "<p>Roughly analogous to (type *) inst, but check if valid first.
"
        DISCUSSION: "<p>OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Pointer to object that you wish to attempt to type cast.  May be 0."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSCheckTypeInst
        APIUID: //test_ref/cpp/macro/OSCheckTypeInst
        ABSTRACT: "<p>Is the target object a subclass of the reference object?
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference instance of an object, desired type."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Instance of object to check for type compatibility."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSMemberFunctionCast
        APIUID: //test_ref/cpp/macro/OSMemberFunctionCast
        ABSTRACT: "<p>Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: cptrtype
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: func
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The type of pointer function desired."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The this pointer of the object whose function you wish to cache."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: func
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The pointer to member function itself, something like &Base::func."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
-=: NAMED OBJECT PARSE TREES :=-
OBJECT: OSMetaClassBase (HeaderDoc::CPPClass)
+---class
+--- 
+---OSMetaClassBase
+---[ NEWLINE ]
+---{
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeAlloc
|   |   +---
@abstract Allocate an instance of the desired object.
|   |   +---
@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
|   |   +---
@param type Name of the desired type to be created.
|   |   +---
@result 'this' if object cas been successfully created.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeAlloc
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---alloc
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeID
|   |   +---
@abstract Given the name of a class return it's typeID
|   |   +---
@param type Name of the desired type, eg. OSObject.
|   |   +---
@result A unique Type ID for the class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeID
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeIDInst
|   |   +---
@abstract Given a pointer to an object return it's typeID
|   |   +---
@param typeinst An instance of an OSObject subclass.
|   |   +---
@result The typeID, ie. OSMetaClass *.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeIDInst
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---getMetaClass
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSDynamicCast
|   |   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   |   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   |   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   |   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   |   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSDynamicCast
|   |   +---(
|   |   +---type
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +---        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---safeMetaCast
|   |   +---(
|   |   +---(
|   |   +---inst
|   |   +---)
|   |   +---,
|   |   +---  
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSCheckTypeInst
|   |   +---
@abstract Is the target object a subclass of the reference object?
|   |   +---
@param typeinst Reference instance of an object, desired type.
|   |   +---
@param inst Instance of object to check for type compatibility.
|   |   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSCheckTypeInst
|   |   +---(
|   |   +---typeinst
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +--- 
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---checkTypeInst
|   |   +---(
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---typeinst
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---the conversion of functions that are from MULTIPLY inherited classes.
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-typedef (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---*
|   |   +---_ptf_t
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-static (HAS STATE)
|   +--- 
|   +---inline
|   +--- 
|   +---_ptf_t
|   +---[ NEWLINE ]
|   +---_ptmf2ptf
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   |   +---OSMetaClassBase
|   |   |   +---::
|   |   |   +---*
|   |   |   +---func
|   |   |   +---)
|   |   +---(
|   |   |   +---void
|   |   |   +---)
|   |   +---)
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMemberFunctionCast
|   |   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   |   +---
@param type The type of pointer function desired.
|   |   +---
@param self The this pointer of the object whose function you wish to cache.
|   |   +---
@param func The pointer to member function itself, something like &Base::func.
|   |   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSMemberFunctionCast
|   |   +---(
|   |   +---cptrtype
|   |   +---,
|   |   +--- 
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---cptrtype
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---                                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---            
|   |   +---_ptmf2ptf
|   |   +---(
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---(
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---)
|   |   +---(
|   |   +---void
|   |   +---)
|   |   +---)
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---~
|   +---OSMetaClassBase
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Disable copy constructors of OSMetaClassBase based objects
|   |   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function operator =
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-void (HAS STATE)
|   +--- 
|   +---operator
|   +--- 
|   +---=
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMetaClassBase
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Primary implementation of the release mechanism.
|   |   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   |   +---
@param when When retainCount == when then call free(). 
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function getRetainCount
|   |   +---
@abstract How many times has this object been retained?
|   |   +---
@result Current retain count
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---int
|   +--- 
|   +---getRetainCount
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function retain
|   |   +---
@abstract Retain a reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---retain
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Release a reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function serialize
|   |   +---
@abstract 
|   |   +---
@discussion 
|   |   +---
@param s
|   |   +---
@result 
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---serialize
|   +---(
|   |   +---OSSerialize
|   |   +--- 
|   |   +---*
|   |   +---s
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +--- 
|   +---getMetaClass
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function isEqualTo
|   |   +---
@abstract Is this == anObj?
|   |   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   |   +---
@param anObj Object to compare 'this' to.
|   |   +---
@result true if the objects are equivalent, false otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---isEqualTo
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---anObj
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract Check to see if this object is or inherits from the given type.
|   |   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   |   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSSymbol of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSSymbol
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSString of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSString
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta const char * C String of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---char
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Helper inlines for runtime type preprocessor macros
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---[ NEWLINE ]
|   +---    
|   +---safeMetaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---me
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toType
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---bool
|   +---[ NEWLINE ]
|   +---    
|   +---checkTypeInst
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---typeinst
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRetain
|   |   +---
@abstract Retain a tagged reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRetain
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Virtual Padding
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase3
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase4
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase5
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase6
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase7
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---}
+---;
+--- 
+---[ NEWLINE ]
END OF OBJECT


OBJECT: operator = (HeaderDoc::Function)
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: getRetainCount (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: retain (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: serialize (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: isEqualTo (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRetain (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeAlloc (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeAlloc
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---(
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +----
|   +--->
|   +---alloc
|   +---(
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeID
|   +---
@abstract Given the name of a class return it's typeID
|   +---
@param type Name of the desired type, eg. OSObject.
|   +---
@result A unique Type ID for the class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeID
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeIDInst
|   +---
@abstract Given a pointer to an object return it's typeID
|   +---
@param typeinst An instance of an OSObject subclass.
|   +---
@result The typeID, ie. OSMetaClass *.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeID (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeID
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeIDInst
|   +---
@abstract Given a pointer to an object return it's typeID
|   +---
@param typeinst An instance of an OSObject subclass.
|   +---
@result The typeID, ie. OSMetaClass *.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeIDInst (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSDynamicCast (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSCheckTypeInst (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMemberFunctionCast (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT



-=: HTML OUTPUT OF PARSE TREES :=-
OBJECT: OSMetaClassBase (HeaderDoc::CPPClass)
	<span class="keyword">class</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> { 
	    <span class="keyword">public</span>: <span class="comment">/*! @function OSTypeAlloc
	@abstract Allocate an instance of the desired object.
	@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
	@param type Name of the desired type to be created.
	@result 'this' if object cas been successfully created.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeAlloc //test_ref/cpp/tdef/OSTypeAlloc //test_ref/cpp/tag/OSTypeAlloc //test_ref/cpp/econst/OSTypeAlloc //test_ref/cpp/struct/OSTypeAlloc //test_ref/cpp/data/OSTypeAlloc //test_ref/cpp/clconst/OSTypeAlloc //test_ref/cpp/intf/OSTypeAlloc //test_ref/cpp/instm/OSTypeAlloc //test_ref/cpp/clm/OSTypeAlloc //test_ref/cpp/intfcm/OSTypeAlloc //test_ref/cpp/intfm/OSTypeAlloc //test_ref/cpp/func/OSTypeAlloc //test_ref/cpp/ftmplt/OSTypeAlloc //test_ref/cpp/defn/OSTypeAlloc //test_ref/cpp/macro/OSTypeAlloc //test_ref/doc/com/intfm/OSTypeAlloc" --><span class="preprocessor">OSTypeAlloc</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/alloc //test_ref/cpp/tdef/alloc //test_ref/cpp/tag/alloc //test_ref/cpp/econst/alloc //test_ref/cpp/struct/alloc //test_ref/cpp/data/alloc //test_ref/cpp/clconst/alloc //test_ref/cpp/intf/alloc //test_ref/cpp/instm/alloc //test_ref/cpp/clm/alloc //test_ref/cpp/intfcm/alloc //test_ref/cpp/intfm/alloc //test_ref/cpp/func/alloc //test_ref/cpp/ftmplt/alloc //test_ref/cpp/defn/alloc //test_ref/cpp/macro/alloc //test_ref/doc/com/intfm/alloc" --><span class="preprocessor">alloc</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSTypeID
	@abstract Given the name of a class return it's typeID
	@param type Name of the desired type, eg. OSObject.
	@result A unique Type ID for the class.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeID //test_ref/cpp/tdef/OSTypeID //test_ref/cpp/tag/OSTypeID //test_ref/cpp/econst/OSTypeID //test_ref/cpp/struct/OSTypeID //test_ref/cpp/data/OSTypeID //test_ref/cpp/clconst/OSTypeID //test_ref/cpp/intf/OSTypeID //test_ref/cpp/instm/OSTypeID //test_ref/cpp/clm/OSTypeID //test_ref/cpp/intfcm/OSTypeID //test_ref/cpp/intfm/OSTypeID //test_ref/cpp/func/OSTypeID //test_ref/cpp/ftmplt/OSTypeID //test_ref/cpp/defn/OSTypeID //test_ref/cpp/macro/OSTypeID //test_ref/doc/com/intfm/OSTypeID" --><span class="preprocessor">OSTypeID</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSTypeIDInst
	@abstract Given a pointer to an object return it's typeID
	@param typeinst An instance of an OSObject subclass.
	@result The typeID, ie. OSMetaClass *.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeIDInst //test_ref/cpp/tdef/OSTypeIDInst //test_ref/cpp/tag/OSTypeIDInst //test_ref/cpp/econst/OSTypeIDInst //test_ref/cpp/struct/OSTypeIDInst //test_ref/cpp/data/OSTypeIDInst //test_ref/cpp/clconst/OSTypeIDInst //test_ref/cpp/intf/OSTypeIDInst //test_ref/cpp/instm/OSTypeIDInst //test_ref/cpp/clm/OSTypeIDInst //test_ref/cpp/intfcm/OSTypeIDInst //test_ref/cpp/intfm/OSTypeIDInst //test_ref/cpp/func/OSTypeIDInst //test_ref/cpp/ftmplt/OSTypeIDInst //test_ref/cpp/defn/OSTypeIDInst //test_ref/cpp/macro/OSTypeIDInst //test_ref/doc/com/intfm/OSTypeIDInst" --><span class="preprocessor">OSTypeIDInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/getMetaClass //test_ref/cpp/tdef/getMetaClass //test_ref/cpp/tag/getMetaClass //test_ref/cpp/econst/getMetaClass //test_ref/cpp/struct/getMetaClass //test_ref/cpp/data/getMetaClass //test_ref/cpp/clconst/getMetaClass //test_ref/cpp/intf/getMetaClass //test_ref/cpp/instm/getMetaClass //test_ref/cpp/clm/getMetaClass //test_ref/cpp/intfcm/getMetaClass //test_ref/cpp/intfm/getMetaClass //test_ref/cpp/func/getMetaClass //test_ref/cpp/ftmplt/getMetaClass //test_ref/cpp/defn/getMetaClass //test_ref/cpp/macro/getMetaClass //test_ref/doc/com/intfm/getMetaClass" --><span class="preprocessor">getMetaClass</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSDynamicCast
	@abstract Roughly analogous to (type *) inst, but check if valid first.
	@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast&lt;T&gt; operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
	@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
	@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
	@result inst if object non-zero and it is of the desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSDynamicCast //test_ref/cpp/tdef/OSDynamicCast //test_ref/cpp/tag/OSDynamicCast //test_ref/cpp/econst/OSDynamicCast //test_ref/cpp/struct/OSDynamicCast //test_ref/cpp/data/OSDynamicCast //test_ref/cpp/clconst/OSDynamicCast //test_ref/cpp/intf/OSDynamicCast //test_ref/cpp/instm/OSDynamicCast //test_ref/cpp/clm/OSDynamicCast //test_ref/cpp/intfcm/OSDynamicCast //test_ref/cpp/intfm/OSDynamicCast //test_ref/cpp/func/OSDynamicCast //test_ref/cpp/ftmplt/OSDynamicCast //test_ref/cpp/defn/OSDynamicCast //test_ref/cpp/macro/OSDynamicCast //test_ref/doc/com/intfm/OSDynamicCast" --><span class="preprocessor">OSDynamicCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/safeMetaCast //test_ref/cpp/tdef/safeMetaCast //test_ref/cpp/tag/safeMetaCast //test_ref/cpp/econst/safeMetaCast //test_ref/cpp/struct/safeMetaCast //test_ref/cpp/data/safeMetaCast //test_ref/cpp/clconst/safeMetaCast //test_ref/cpp/intf/safeMetaCast //test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast //test_ref/doc/com/intfm/safeMetaCast" --><span class="preprocessor">safeMetaCast</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSCheckTypeInst
	@abstract Is the target object a subclass of the reference object?
	@param typeinst Reference instance of an object, desired type.
	@param inst Instance of object to check for type compatibility.
	@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSCheckTypeInst //test_ref/cpp/tdef/OSCheckTypeInst //test_ref/cpp/tag/OSCheckTypeInst //test_ref/cpp/econst/OSCheckTypeInst //test_ref/cpp/struct/OSCheckTypeInst //test_ref/cpp/data/OSCheckTypeInst //test_ref/cpp/clconst/OSCheckTypeInst //test_ref/cpp/intf/OSCheckTypeInst //test_ref/cpp/instm/OSCheckTypeInst //test_ref/cpp/clm/OSCheckTypeInst //test_ref/cpp/intfcm/OSCheckTypeInst //test_ref/cpp/intfm/OSCheckTypeInst //test_ref/cpp/func/OSCheckTypeInst //test_ref/cpp/ftmplt/OSCheckTypeInst //test_ref/cpp/defn/OSCheckTypeInst //test_ref/cpp/macro/OSCheckTypeInst //test_ref/doc/com/intfm/OSCheckTypeInst" --><span class="preprocessor">OSCheckTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/checkTypeInst //test_ref/cpp/tdef/checkTypeInst //test_ref/cpp/tag/checkTypeInst //test_ref/cpp/econst/checkTypeInst //test_ref/cpp/struct/checkTypeInst //test_ref/cpp/data/checkTypeInst //test_ref/cpp/clconst/checkTypeInst //test_ref/cpp/intf/checkTypeInst //test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst //test_ref/doc/com/intfm/checkTypeInst" --><span class="preprocessor">checkTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span>   
	    <span class="comment">// Arcane evil code interprets a C++ pointer to function as specified in the</span> 
	    <span class="comment">// -fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW</span> 
	    <span class="comment">// the conversion of functions that are from MULTIPLY inherited classes.</span>  
	    <span class="keyword">typedef</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> (<span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/_ptf_t //test_ref/cpp/clm/_ptf_t //test_ref/cpp/intfcm/_ptf_t //test_ref/cpp/intfm/_ptf_t //test_ref/cpp/func/_ptf_t //test_ref/cpp/ftmplt/_ptf_t //test_ref/cpp/defn/_ptf_t //test_ref/cpp/macro/_ptf_t" --><span class="function">_ptf_t</span><!-- /a -->)(
	        <span class="param">void</span>);  
	    <span class="keyword">static</span> <span class="keyword">inline</span> <!-- a logicalPath="//test_ref/cpp/cl/_ptf_t //test_ref/cpp/tdef/_ptf_t //test_ref/cpp/tag/_ptf_t //test_ref/cpp/econst/_ptf_t //test_ref/cpp/struct/_ptf_t //test_ref/cpp/clconst/_ptf_t //test_ref/cpp/intf/_ptf_t" --><span class="type">_ptf_t</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf" --><span class="function">_ptmf2ptf</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/self //test_ref/cpp/data/self" --><span class="var">self</span><!-- /a -->,
	        <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> (<!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a -->::<span class="type">*</span><span class="param">func</span>)(<!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a -->))   <span class="comment">/*! @function OSMemberFunctionCast
	@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
	@param type The type of pointer function desired.
	@param self The this pointer of the object whose function you wish to cache.
	@param func The pointer to member function itself, something like &amp;Base::func.
	@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMemberFunctionCast //test_ref/cpp/tdef/OSMemberFunctionCast //test_ref/cpp/tag/OSMemberFunctionCast //test_ref/cpp/econst/OSMemberFunctionCast //test_ref/cpp/struct/OSMemberFunctionCast //test_ref/cpp/data/OSMemberFunctionCast //test_ref/cpp/clconst/OSMemberFunctionCast //test_ref/cpp/intf/OSMemberFunctionCast //test_ref/cpp/instm/OSMemberFunctionCast //test_ref/cpp/clm/OSMemberFunctionCast //test_ref/cpp/intfcm/OSMemberFunctionCast //test_ref/cpp/intfm/OSMemberFunctionCast //test_ref/cpp/func/OSMemberFunctionCast //test_ref/cpp/ftmplt/OSMemberFunctionCast //test_ref/cpp/defn/OSMemberFunctionCast //test_ref/cpp/macro/OSMemberFunctionCast //test_ref/doc/com/intfm/OSMemberFunctionCast" --><span class="preprocessor">OSMemberFunctionCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <!-- a logicalPath="//test_ref/cpp/cl/_ptmf2ptf //test_ref/cpp/tdef/_ptmf2ptf //test_ref/cpp/tag/_ptmf2ptf //test_ref/cpp/econst/_ptmf2ptf //test_ref/cpp/struct/_ptmf2ptf //test_ref/cpp/data/_ptmf2ptf //test_ref/cpp/clconst/_ptmf2ptf //test_ref/cpp/intf/_ptmf2ptf //test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf //test_ref/doc/com/intfm/_ptmf2ptf" --><span class="preprocessor">_ptmf2ptf</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span>  
	    <span class="keyword">protected</span>: <!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> ~<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->();  
	    <span class="keyword">private</span>: <span class="comment">// Disable copy constructors of OSMetaClassBase based objects</span> 
	    <span class="comment">/*! @function operator =
	@abstract Disable implicit copy constructor by making private
	@param src Reference to source object that isn't allowed to be copied</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <span class="keyword">operator</span> =(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>);  
	    <span class="comment">/*! @function OSMetaClassBase
	@abstract Disable implicit copy constructor by making private
	@param src Reference to source object that isn't allowed to be copied</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>);  
	    <span class="keyword">public</span>: <span class="comment">/*! @function release
	@abstract Primary implementation of the release mechanism.
	@discussion  If $link retainCount &lt;= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. </span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <span class="param">when</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function getRetainCount
	@abstract How many times has this object been retained?
	@result Current retain count</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/getRetainCount //test_ref/cpp/clm/getRetainCount //test_ref/cpp/intfcm/getRetainCount //test_ref/cpp/intfm/getRetainCount //test_ref/cpp/func/getRetainCount //test_ref/cpp/ftmplt/getRetainCount //test_ref/cpp/defn/getRetainCount //test_ref/cpp/macro/getRetainCount" --><span class="function">getRetainCount</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function retain
	@abstract Retain a reference in this object.</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/retain //test_ref/cpp/clm/retain //test_ref/cpp/intfcm/retain //test_ref/cpp/intfm/retain //test_ref/cpp/func/retain //test_ref/cpp/ftmplt/retain //test_ref/cpp/defn/retain //test_ref/cpp/macro/retain" --><span class="function">retain</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
	    <span class="comment">/*! @function release
	@abstract Release a reference to this object</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function serialize
	@abstract 
	@discussion 
	@param s
	@result </span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/serialize //test_ref/cpp/clm/serialize //test_ref/cpp/intfcm/serialize //test_ref/cpp/intfm/serialize //test_ref/cpp/func/serialize //test_ref/cpp/ftmplt/serialize //test_ref/cpp/defn/serialize //test_ref/cpp/macro/serialize" --><span class="function">serialize</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSSerialize //test_ref/cpp/tdef/OSSerialize //test_ref/cpp/tag/OSSerialize //test_ref/cpp/econst/OSSerialize //test_ref/cpp/struct/OSSerialize //test_ref/cpp/clconst/OSSerialize //test_ref/cpp/intf/OSSerialize" --><span class="type">OSSerialize</span><!-- /a --> <span class="type">*</span><span class="param">s</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span> <!-- a logicalPath="//test_ref/cpp/econst/getMetaClass //test_ref/cpp/data/getMetaClass" --><span class="var">getMetaClass</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function isEqualTo
	@abstract Is this == anObj?
	@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
	@param anObj Object to compare 'this' to.
	@result true if the objects are equivalent, false otherwise.</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/isEqualTo //test_ref/cpp/clm/isEqualTo //test_ref/cpp/intfcm/isEqualTo //test_ref/cpp/intfm/isEqualTo //test_ref/cpp/func/isEqualTo //test_ref/cpp/ftmplt/isEqualTo //test_ref/cpp/defn/isEqualTo //test_ref/cpp/macro/isEqualTo" --><span class="function">isEqualTo</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/anObj //test_ref/cpp/data/anObj" --><span class="var">anObj</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract Check to see if this object is or inherits from the given type.
	@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
	@param toMeta Pointer to a constant OSMetaClass for the desired target type.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;   
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta OSSymbol of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSSymbol //test_ref/cpp/data/OSSymbol" --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta OSString of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSString //test_ref/cpp/data/OSString" --><span class="var">OSString</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta const char * C String of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/char //test_ref/cpp/data/char" --><span class="var">char</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">// Helper inlines for runtime type preprocessor macros</span> 
	    <span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span> <!-- a logicalPath="//test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast" --><span class="function">safeMetaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/me //test_ref/cpp/data/me" --><span class="var">me</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toType //test_ref/cpp/data/toType" --><span class="var">toType</span><!-- /a -->);  
	    <span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst" --><span class="function">checkTypeInst</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/inst //test_ref/cpp/data/inst" --><span class="var">inst</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/typeinst //test_ref/cpp/data/typeinst" --><span class="var">typeinst</span><!-- /a -->);  
	    <span class="keyword">public</span>:  <span class="comment">/*! @function taggedRetain
	@abstract Retain a tagged reference in this object.</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS: virtual void _RESERVEDOSMetaClassBase0();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRetain //test_ref/cpp/clm/taggedRetain //test_ref/cpp/intfcm/taggedRetain //test_ref/cpp/intfm/taggedRetain //test_ref/cpp/func/taggedRetain //test_ref/cpp/ftmplt/taggedRetain //test_ref/cpp/defn/taggedRetain //test_ref/cpp/macro/taggedRetain" --><span class="function">taggedRetain</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function taggedRelease
	@abstract Release a tagged reference to this object</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS:  virtual void _RESERVEDOSMetaClassBase1();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">protected</span>: <span class="comment">/*! @function taggedRelease
	@abstract Release a tagged reference to this object and free if retainCount == when on entry</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS:  virtual void _RESERVEDOSMetaClassBase2();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/int //test_ref/cpp/data/int" --><span class="var">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/econst/when //test_ref/cpp/data/when" --><span class="var">when</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">private</span>: <span class="comment">// Virtual Padding</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/func/_RESERVEDOSMetaClassBase3 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase3 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase3 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase3" --><span class="function">_RESERVEDOSMetaClassBase3</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/func/_RESERVEDOSMetaClassBase4 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase4 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase4 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase4" --><span class="function">_RESERVEDOSMetaClassBase4</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/func/_RESERVEDOSMetaClassBase5 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase5 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase5 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase5" --><span class="function">_RESERVEDOSMetaClassBase5</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/func/_RESERVEDOSMetaClassBase6 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase6 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase6 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase6" --><span class="function">_RESERVEDOSMetaClassBase6</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/func/_RESERVEDOSMetaClassBase7 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase7 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase7 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase7" --><span class="function">_RESERVEDOSMetaClassBase7</span><!-- /a -->(); 
	};  
END OF OBJECT


OBJECT: operator = (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <span class="keyword">operator</span> =(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>); 
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>); 
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <span class="param">when</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: getRetainCount (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/getRetainCount //test_ref/cpp/clm/getRetainCount //test_ref/cpp/intfcm/getRetainCount //test_ref/cpp/intfm/getRetainCount //test_ref/cpp/func/getRetainCount //test_ref/cpp/ftmplt/getRetainCount //test_ref/cpp/defn/getRetainCount //test_ref/cpp/macro/getRetainCount" --><span class="function">getRetainCount</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: retain (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/retain //test_ref/cpp/clm/retain //test_ref/cpp/intfcm/retain //test_ref/cpp/intfm/retain //test_ref/cpp/func/retain //test_ref/cpp/ftmplt/retain //test_ref/cpp/defn/retain //test_ref/cpp/macro/retain" --><span class="function">retain</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: serialize (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/serialize //test_ref/cpp/clm/serialize //test_ref/cpp/intfcm/serialize //test_ref/cpp/intfm/serialize //test_ref/cpp/func/serialize //test_ref/cpp/ftmplt/serialize //test_ref/cpp/defn/serialize //test_ref/cpp/macro/serialize" --><span class="function">serialize</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSSerialize //test_ref/cpp/tdef/OSSerialize //test_ref/cpp/tag/OSSerialize //test_ref/cpp/econst/OSSerialize //test_ref/cpp/struct/OSSerialize //test_ref/cpp/clconst/OSSerialize //test_ref/cpp/intf/OSSerialize" --><span class="type">OSSerialize</span><!-- /a --> <span class="type">*</span><span class="param">s</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: isEqualTo (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/isEqualTo //test_ref/cpp/clm/isEqualTo //test_ref/cpp/intfcm/isEqualTo //test_ref/cpp/intfm/isEqualTo //test_ref/cpp/func/isEqualTo //test_ref/cpp/ftmplt/isEqualTo //test_ref/cpp/defn/isEqualTo //test_ref/cpp/macro/isEqualTo" --><span class="function">isEqualTo</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/anObj //test_ref/cpp/data/anObj" --><span class="var">anObj</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSSymbol //test_ref/cpp/data/OSSymbol" --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSString //test_ref/cpp/data/OSString" --><span class="var">OSString</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/char //test_ref/cpp/data/char" --><span class="var">char</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: taggedRetain (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRetain //test_ref/cpp/clm/taggedRetain //test_ref/cpp/intfcm/taggedRetain //test_ref/cpp/intfm/taggedRetain //test_ref/cpp/func/taggedRetain //test_ref/cpp/ftmplt/taggedRetain //test_ref/cpp/defn/taggedRetain //test_ref/cpp/macro/taggedRetain" --><span class="function">taggedRetain</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a -->,
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/int //test_ref/cpp/data/int" --><span class="var">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/econst/when //test_ref/cpp/data/when" --><span class="var">when</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: OSTypeAlloc (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeAlloc //test_ref/cpp/tdef/OSTypeAlloc //test_ref/cpp/tag/OSTypeAlloc //test_ref/cpp/econst/OSTypeAlloc //test_ref/cpp/struct/OSTypeAlloc //test_ref/cpp/data/OSTypeAlloc //test_ref/cpp/clconst/OSTypeAlloc //test_ref/cpp/intf/OSTypeAlloc //test_ref/cpp/instm/OSTypeAlloc //test_ref/cpp/clm/OSTypeAlloc //test_ref/cpp/intfcm/OSTypeAlloc //test_ref/cpp/intfm/OSTypeAlloc //test_ref/cpp/func/OSTypeAlloc //test_ref/cpp/ftmplt/OSTypeAlloc //test_ref/cpp/defn/OSTypeAlloc //test_ref/cpp/macro/OSTypeAlloc //test_ref/doc/com/intfm/OSTypeAlloc" --><span class="preprocessor">OSTypeAlloc</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/alloc //test_ref/cpp/tdef/alloc //test_ref/cpp/tag/alloc //test_ref/cpp/econst/alloc //test_ref/cpp/struct/alloc //test_ref/cpp/data/alloc //test_ref/cpp/clconst/alloc //test_ref/cpp/intf/alloc //test_ref/cpp/instm/alloc //test_ref/cpp/clm/alloc //test_ref/cpp/intfcm/alloc //test_ref/cpp/intfm/alloc //test_ref/cpp/func/alloc //test_ref/cpp/ftmplt/alloc //test_ref/cpp/defn/alloc //test_ref/cpp/macro/alloc //test_ref/doc/com/intfm/alloc" --><span class="preprocessor">alloc</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSTypeID (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeID //test_ref/cpp/tdef/OSTypeID //test_ref/cpp/tag/OSTypeID //test_ref/cpp/econst/OSTypeID //test_ref/cpp/struct/OSTypeID //test_ref/cpp/data/OSTypeID //test_ref/cpp/clconst/OSTypeID //test_ref/cpp/intf/OSTypeID //test_ref/cpp/instm/OSTypeID //test_ref/cpp/clm/OSTypeID //test_ref/cpp/intfcm/OSTypeID //test_ref/cpp/intfm/OSTypeID //test_ref/cpp/func/OSTypeID //test_ref/cpp/ftmplt/OSTypeID //test_ref/cpp/defn/OSTypeID //test_ref/cpp/macro/OSTypeID //test_ref/doc/com/intfm/OSTypeID" --><span class="preprocessor">OSTypeID</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSTypeIDInst (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeIDInst //test_ref/cpp/tdef/OSTypeIDInst //test_ref/cpp/tag/OSTypeIDInst //test_ref/cpp/econst/OSTypeIDInst //test_ref/cpp/struct/OSTypeIDInst //test_ref/cpp/data/OSTypeIDInst //test_ref/cpp/clconst/OSTypeIDInst //test_ref/cpp/intf/OSTypeIDInst //test_ref/cpp/instm/OSTypeIDInst //test_ref/cpp/clm/OSTypeIDInst //test_ref/cpp/intfcm/OSTypeIDInst //test_ref/cpp/intfm/OSTypeIDInst //test_ref/cpp/func/OSTypeIDInst //test_ref/cpp/ftmplt/OSTypeIDInst //test_ref/cpp/defn/OSTypeIDInst //test_ref/cpp/macro/OSTypeIDInst //test_ref/doc/com/intfm/OSTypeIDInst" --><span class="preprocessor">OSTypeIDInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/getMetaClass //test_ref/cpp/tdef/getMetaClass //test_ref/cpp/tag/getMetaClass //test_ref/cpp/econst/getMetaClass //test_ref/cpp/struct/getMetaClass //test_ref/cpp/data/getMetaClass //test_ref/cpp/clconst/getMetaClass //test_ref/cpp/intf/getMetaClass //test_ref/cpp/instm/getMetaClass //test_ref/cpp/clm/getMetaClass //test_ref/cpp/intfcm/getMetaClass //test_ref/cpp/intfm/getMetaClass //test_ref/cpp/func/getMetaClass //test_ref/cpp/ftmplt/getMetaClass //test_ref/cpp/defn/getMetaClass //test_ref/cpp/macro/getMetaClass //test_ref/doc/com/intfm/getMetaClass" --><span class="preprocessor">getMetaClass</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSDynamicCast (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSDynamicCast //test_ref/cpp/tdef/OSDynamicCast //test_ref/cpp/tag/OSDynamicCast //test_ref/cpp/econst/OSDynamicCast //test_ref/cpp/struct/OSDynamicCast //test_ref/cpp/data/OSDynamicCast //test_ref/cpp/clconst/OSDynamicCast //test_ref/cpp/intf/OSDynamicCast //test_ref/cpp/instm/OSDynamicCast //test_ref/cpp/clm/OSDynamicCast //test_ref/cpp/intfcm/OSDynamicCast //test_ref/cpp/intfm/OSDynamicCast //test_ref/cpp/func/OSDynamicCast //test_ref/cpp/ftmplt/OSDynamicCast //test_ref/cpp/defn/OSDynamicCast //test_ref/cpp/macro/OSDynamicCast //test_ref/doc/com/intfm/OSDynamicCast" --><span class="preprocessor">OSDynamicCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/safeMetaCast //test_ref/cpp/tdef/safeMetaCast //test_ref/cpp/tag/safeMetaCast //test_ref/cpp/econst/safeMetaCast //test_ref/cpp/struct/safeMetaCast //test_ref/cpp/data/safeMetaCast //test_ref/cpp/clconst/safeMetaCast //test_ref/cpp/intf/safeMetaCast //test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast //test_ref/doc/com/intfm/safeMetaCast" --><span class="preprocessor">safeMetaCast</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSCheckTypeInst (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSCheckTypeInst //test_ref/cpp/tdef/OSCheckTypeInst //test_ref/cpp/tag/OSCheckTypeInst //test_ref/cpp/econst/OSCheckTypeInst //test_ref/cpp/struct/OSCheckTypeInst //test_ref/cpp/data/OSCheckTypeInst //test_ref/cpp/clconst/OSCheckTypeInst //test_ref/cpp/intf/OSCheckTypeInst //test_ref/cpp/instm/OSCheckTypeInst //test_ref/cpp/clm/OSCheckTypeInst //test_ref/cpp/intfcm/OSCheckTypeInst //test_ref/cpp/intfm/OSCheckTypeInst //test_ref/cpp/func/OSCheckTypeInst //test_ref/cpp/ftmplt/OSCheckTypeInst //test_ref/cpp/defn/OSCheckTypeInst //test_ref/cpp/macro/OSCheckTypeInst //test_ref/doc/com/intfm/OSCheckTypeInst" --><span class="preprocessor">OSCheckTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/checkTypeInst //test_ref/cpp/tdef/checkTypeInst //test_ref/cpp/tag/checkTypeInst //test_ref/cpp/econst/checkTypeInst //test_ref/cpp/struct/checkTypeInst //test_ref/cpp/data/checkTypeInst //test_ref/cpp/clconst/checkTypeInst //test_ref/cpp/intf/checkTypeInst //test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst //test_ref/doc/com/intfm/checkTypeInst" --><span class="preprocessor">checkTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSMemberFunctionCast (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMemberFunctionCast //test_ref/cpp/tdef/OSMemberFunctionCast //test_ref/cpp/tag/OSMemberFunctionCast //test_ref/cpp/econst/OSMemberFunctionCast //test_ref/cpp/struct/OSMemberFunctionCast //test_ref/cpp/data/OSMemberFunctionCast //test_ref/cpp/clconst/OSMemberFunctionCast //test_ref/cpp/intf/OSMemberFunctionCast //test_ref/cpp/instm/OSMemberFunctionCast //test_ref/cpp/clm/OSMemberFunctionCast //test_ref/cpp/intfcm/OSMemberFunctionCast //test_ref/cpp/intfm/OSMemberFunctionCast //test_ref/cpp/func/OSMemberFunctionCast //test_ref/cpp/ftmplt/OSMemberFunctionCast //test_ref/cpp/defn/OSMemberFunctionCast //test_ref/cpp/macro/OSMemberFunctionCast //test_ref/doc/com/intfm/OSMemberFunctionCast" --><span class="preprocessor">OSMemberFunctionCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <!-- a logicalPath="//test_ref/cpp/cl/_ptmf2ptf //test_ref/cpp/tdef/_ptmf2ptf //test_ref/cpp/tag/_ptmf2ptf //test_ref/cpp/econst/_ptmf2ptf //test_ref/cpp/struct/_ptmf2ptf //test_ref/cpp/data/_ptmf2ptf //test_ref/cpp/clconst/_ptmf2ptf //test_ref/cpp/intf/_ptmf2ptf //test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf //test_ref/doc/com/intfm/_ptmf2ptf" --><span class="preprocessor">_ptmf2ptf</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT



$482950|-=: TOP LEVEL COMMENT PARSE VALUES :=-
inHeader: 0
inClass: 0
inInterface: 0
inCPPHeader: 0
inOCCHeader: 0
inPerlScript: 0
inShellScript: 0
inPHPScript: 0
inJavaSource: 0
inFunctionGroup: 0
inGroup: 0
inFunction: 0
inPDefine: 0
inTypedef: 0
inUnion: 0
inStruct: 0
inConstant: 0
inVar: 0
inEnum: 0
inMethod: 0
inAvailabilityMacro: 0
inUnknown: 1
classType: unknown
inputCounter: 0
blockOffset: 0
fullpath: /test_suite_bogus_path/class_4.test
-=: BLOCKPARSE PARSER STATE KEYS :=-
$parserState->{FULLPATH} => /test_suite_bogus_path/class_4.test
$parserState->{ISFORWARDDECLARATION} => 0
$parserState->{NEXTTOKENNOCPP} => 0
$parserState->{availability} => 
$parserState->{backslashcount} => 0
$parserState->{basetype} => 
$parserState->{bracePending} => 0
$parserState->{callbackIsTypedef} => 0
$parserState->{callbackName} => 
$parserState->{callbackNamePending} => -1
$parserState->{categoryClass} => 
$parserState->{classNameFound} => 1
$parserState->{classtype} => class
$parserState->{forceClassDone} => 1
$parserState->{freezeStack} => ARRAY(OBJID)
$parserState->{freezereturn} => 1
$parserState->{frozensodname} => 
$parserState->{functionReturnsCallback} => 0
$parserState->{hollow} => HeaderDoc::ParseTree=HASH(OBJID)
$parserState->{inBrackets} => 0
$parserState->{inChar} => 0
$parserState->{inClass} => 1
$parserState->{inComment} => 0
$parserState->{inInlineComment} => 0
$parserState->{inMacro} => 0
$parserState->{inMacroLine} => 0
$parserState->{inOperator} => 0
$parserState->{inPrivateParamTypes} => 0
$parserState->{inString} => 0
$parserState->{inTemplate} => 0
$parserState->{initbsCount} => 0
$parserState->{inputCounter} => 142
$parserState->{kr_c_function} => 0
$parserState->{kr_c_name} => 
$parserState->{lang} => C
$parserState->{lastTreeNode} => HeaderDoc::ParseTree=HASH(OBJID)
$parserState->{lastsymbol} => ;
$parserState->{macroNoTrunc} => 1
$parserState->{name} => 
$parserState->{namePending} => 0
$parserState->{noInsert} => 0
$parserState->{occmethod} => 0
$parserState->{occmethodname} => 
$parserState->{occparmlabelfound} => 2
$parserState->{onlyComments} => 0
$parserState->{parsedParamList} => ARRAY(OBJID)
$parserState->{parsedParamParse} => 1
$parserState->{posstypes} => 
$parserState->{posstypesPending} => 0
$parserState->{pplStack} => ARRAY(OBJID)
$parserState->{preEqualsSymbol} => 
$parserState->{preTemplateSymbol} => 
$parserState->{preclasssodtype} => class
$parserState->{returntype} => class OSMetaClassBase  
$parserState->{seenBraces} => 0
$parserState->{seenMacroPart} => 0
$parserState->{seenTilde} => 0
$parserState->{simpleTDcontents} => 
$parserState->{simpleTypedef} => 0
$parserState->{sodclass} => class
$parserState->{sodname} => OSMetaClassBase
$parserState->{sodtype} => 
$parserState->{sodtypeclasstoken} => class
$parserState->{stackFrozen} => 0
$parserState->{startOfDec} => 1
$parserState->{storeDec} => 
$parserState->{temponlyComments} => 0
$parserState->{treePopTwo} => 0
$parserState->{typestring} => OSMetaClassBase
$parserState->{value} => 
$parserState->{valuepending} => 0
-=: BLOCKPARSE RETURN VALUES :=-
newcount: 142
typelist: class
namelist: OSMetaClassBase
posstypes: 
value: 
returntype: 
pridec: 
simpleTDcontents: 
bpavail: 
blockOffset: 79
conformsToList: 
functionContents: 
extendsClass: 
implementsClass: 
-=: LIST OF PARSED PARAMETERS :=-
-=: DUMP OF PARSE TREE :=-
+---class
+--- 
+---OSMetaClassBase
+---[ NEWLINE ]
+---{
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeAlloc
|   |   +---
@abstract Allocate an instance of the desired object.
|   |   +---
@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
|   |   +---
@param type Name of the desired type to be created.
|   |   +---
@result 'this' if object cas been successfully created.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeAlloc
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---alloc
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeID
|   |   +---
@abstract Given the name of a class return it's typeID
|   |   +---
@param type Name of the desired type, eg. OSObject.
|   |   +---
@result A unique Type ID for the class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeID
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeIDInst
|   |   +---
@abstract Given a pointer to an object return it's typeID
|   |   +---
@param typeinst An instance of an OSObject subclass.
|   |   +---
@result The typeID, ie. OSMetaClass *.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeIDInst
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---getMetaClass
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSDynamicCast
|   |   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   |   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   |   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   |   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   |   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSDynamicCast
|   |   +---(
|   |   +---type
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +---        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---safeMetaCast
|   |   +---(
|   |   +---(
|   |   +---inst
|   |   +---)
|   |   +---,
|   |   +---  
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSCheckTypeInst
|   |   +---
@abstract Is the target object a subclass of the reference object?
|   |   +---
@param typeinst Reference instance of an object, desired type.
|   |   +---
@param inst Instance of object to check for type compatibility.
|   |   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSCheckTypeInst
|   |   +---(
|   |   +---typeinst
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +--- 
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---checkTypeInst
|   |   +---(
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---typeinst
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---the conversion of functions that are from MULTIPLY inherited classes.
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-typedef (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---*
|   |   +---_ptf_t
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-static (HAS STATE)
|   +--- 
|   +---inline
|   +--- 
|   +---_ptf_t
|   +---[ NEWLINE ]
|   +---_ptmf2ptf
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   |   +---OSMetaClassBase
|   |   |   +---::
|   |   |   +---*
|   |   |   +---func
|   |   |   +---)
|   |   +---(
|   |   |   +---void
|   |   |   +---)
|   |   +---)
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMemberFunctionCast
|   |   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   |   +---
@param type The type of pointer function desired.
|   |   +---
@param self The this pointer of the object whose function you wish to cache.
|   |   +---
@param func The pointer to member function itself, something like &Base::func.
|   |   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSMemberFunctionCast
|   |   +---(
|   |   +---cptrtype
|   |   +---,
|   |   +--- 
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---cptrtype
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---                                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---            
|   |   +---_ptmf2ptf
|   |   +---(
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---(
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---)
|   |   +---(
|   |   +---void
|   |   +---)
|   |   +---)
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---~
|   +---OSMetaClassBase
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Disable copy constructors of OSMetaClassBase based objects
|   |   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function operator =
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-void (HAS STATE)
|   +--- 
|   +---operator
|   +--- 
|   +---=
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMetaClassBase
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Primary implementation of the release mechanism.
|   |   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   |   +---
@param when When retainCount == when then call free(). 
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function getRetainCount
|   |   +---
@abstract How many times has this object been retained?
|   |   +---
@result Current retain count
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---int
|   +--- 
|   +---getRetainCount
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function retain
|   |   +---
@abstract Retain a reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---retain
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Release a reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function serialize
|   |   +---
@abstract 
|   |   +---
@discussion 
|   |   +---
@param s
|   |   +---
@result 
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---serialize
|   +---(
|   |   +---OSSerialize
|   |   +--- 
|   |   +---*
|   |   +---s
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +--- 
|   +---getMetaClass
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function isEqualTo
|   |   +---
@abstract Is this == anObj?
|   |   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   |   +---
@param anObj Object to compare 'this' to.
|   |   +---
@result true if the objects are equivalent, false otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---isEqualTo
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---anObj
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract Check to see if this object is or inherits from the given type.
|   |   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   |   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSSymbol of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSSymbol
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSString of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSString
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta const char * C String of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---char
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Helper inlines for runtime type preprocessor macros
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---[ NEWLINE ]
|   +---    
|   +---safeMetaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---me
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toType
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---bool
|   +---[ NEWLINE ]
|   +---    
|   +---checkTypeInst
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---typeinst
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRetain
|   |   +---
@abstract Retain a tagged reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRetain
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Virtual Padding
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase3
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase4
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase5
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase6
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase7
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---}
+---;
+--- 
+---[ NEWLINE ]
-=: COMPUTED VALUE :=-
SUCCESS: 0
VALUE: 0
-=: CPP CHANGES :=-
$CPP_HASH{OSCheckTypeInst} => 
    OSMetaClassBase::checkTypeInst(inst, typeinst)
$CPP_HASH{OSDynamicCast} =>        
    ((type *) OSMetaClassBase::safeMetaCast((inst),  (type::metaClass)))
$CPP_HASH{OSMemberFunctionCast} =>                        
    (cptrtype) OSMetaClassBase::                                        
            _ptmf2ptf(self, (void (OSMetaClassBase::*)(void)) func)
$CPP_HASH{OSTypeAlloc} =>        ((type *) ((type::metaClass)->alloc()))
$CPP_HASH{OSTypeID} =>        (type::metaClass)
$CPP_HASH{OSTypeIDInst} =>        ((typeinst)->getMetaClass())
$CPP_ARG_HASH{OSCheckTypeInst} => typeinst, inst
$CPP_ARG_HASH{OSDynamicCast} => type, inst
$CPP_ARG_HASH{OSMemberFunctionCast} => cptrtype, self, func
$CPP_ARG_HASH{OSTypeAlloc} => type
$CPP_ARG_HASH{OSTypeID} => type
$CPP_ARG_HASH{OSTypeIDInst} => typeinst
-=: FOUND MATCH :=-
1
-=: NAMED OBJECTS :=-
TREE COUNT: 0
INDEX GROUP: 
IS BLOCK: 
OBJECT TYPE: HeaderDoc::Header
NAME: class 4
APIUID: //test_ref/doc/header/class_4.test
ABSTRACT: ""
DISCUSSION: "<p></p>"
UPDATED: ""
COPYRIGHT: ""
HTMLMETA: ""
PRIVATEDECLARATION: ""
GROUP: ""
INDEXGROUP: ""
THROWS: ""
XMLTHROWS: ""
UPDATED: ""
LINKAGESTATE: ""
ACCESSCONTROL: ""
AVAILABILITY: ""
LINKUID: ""
ORIGCLASS: ""
ISDEFINE: ""
ISTEMPLATE: ""
VALUE: "UNKNOWN"
RETURNTYPE: ""
LINENUM: ""
CLASS: "HeaderDoc::Header"
MASTERENUM: ""
APIREFSETUPDONE: "1"
TPCDONE: ""
NOREGISTERUID: ""
SUPPRESSCHILDREN: ""
NAMELINE_DISCUSSION: ""
HIDEDOC: ""
HIDESINGLETONS: ""
HIDECONTENTS: ""
MAINOBJECT: ""
LIST ATTRIBUTES: 
SHORT ATTRIBUTES: <p></p>
LONG ATTRIBUTES: <p></p>
    TREE COUNT: 1
    INDEX GROUP: 
    IS BLOCK: 
    OBJECT TYPE: HeaderDoc::CPPClass
    NAME: OSMetaClassBase
    APIUID: 
    ABSTRACT: ""
    DISCUSSION: "<p>OSMetaClassBase "
    UPDATED: ""
    COPYRIGHT: ""
    HTMLMETA: ""
    PRIVATEDECLARATION: ""
    GROUP: ""
    INDEXGROUP: ""
    THROWS: ""
    XMLTHROWS: ""
    UPDATED: ""
    LINKAGESTATE: ""
    ACCESSCONTROL: ""
    AVAILABILITY: ""
    LINKUID: ""
    ORIGCLASS: ""
    ISDEFINE: ""
    ISTEMPLATE: ""
    VALUE: "UNKNOWN"
    RETURNTYPE: ""
    LINENUM: ""
    CLASS: "HeaderDoc::CPPClass"
    MASTERENUM: ""
    APIREFSETUPDONE: "1"
    TPCDONE: ""
    NOREGISTERUID: ""
    SUPPRESSCHILDREN: "1"
    NAMELINE_DISCUSSION: ""
    HIDEDOC: ""
    HIDESINGLETONS: ""
    HIDECONTENTS: ""
    MAINOBJECT: ""
    LIST ATTRIBUTES: 
    SHORT ATTRIBUTES: <p><b>Declared In:</b> <a href="../../index.html" target="_top">class 4</a><br>
</p>
    LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _ptmf2ptf
        APIUID: //test_ref/cpp/clm/OSMetaClassBase/_ptmf2ptf/inline_ptf_t/(constOSMetaClassBase*,void)
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " static inline _ptf_t"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: 
            TYPE:  void
            APIUID: //test_ref/cpp/internal_temporary_object/OSMetaClassBase
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: OSMetaClassBase
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/OSMetaClassBase//()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "protected"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: ~OSMetaClassBase
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/~OSMetaClassBase//()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "protected"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual "
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: operator =
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/operator%3D/void/(OSMetaClassBase%26)
        ABSTRACT: "<p>Disable implicit copy constructor by making private
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: "     void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: OSMetaClassBase &
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference to source object that isn't allowed to be copied"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: OSMetaClassBase
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/OSMetaClassBase//(OSMetaClassBase%26)
        ABSTRACT: "<p>Disable implicit copy constructor by making private
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: OSMetaClassBase &
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: src
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference to source object that isn't allowed to be copied"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: release
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/release/void/(int)
        ABSTRACT: "<p>Primary implementation of the release mechanism.
"
        DISCUSSION: "<p>If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: int
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>When retainCount == when then call free()."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: getRetainCount
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/getRetainCount/int/()
        ABSTRACT: "<p>How many times has this object been retained?
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual int"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: retain
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/retain/void/()
        ABSTRACT: "<p>Retain a reference in this object.
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: release
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/release/void/()
        ABSTRACT: "<p>Release a reference to this object
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: serialize
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/serialize/bool/(OSSerialize*)
        ABSTRACT: ""
        DISCUSSION: "
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: s
            TYPE: OSSerialize *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: s
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: " "
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: getMetaClass
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/getMetaClass/constOSMetaClass*/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual const OSMetaClass *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: isEqualTo
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/isEqualTo/bool/(constOSMetaClassBase*)
        ABSTRACT: "<p>Is this == anObj?
"
        DISCUSSION: "<p>OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: anObj
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: anObj
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Object to compare 'this' to."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSMetaClass*)
        ABSTRACT: "<p>Check to see if this object is or inherits from the given type.
"
        DISCUSSION: "<p>This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSMetaClass *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Pointer to a constant OSMetaClass for the desired target type."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSSymbol*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSSymbol *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>OSSymbol of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constOSString*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const OSString *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>OSString of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: metaCast
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/metaCast/OSMetaClassBase*/(constchar*)
        ABSTRACT: "<p>See OSMetaClassBase::metaCast(const OSMetaClass *)
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: const char *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toMeta
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>const char * C String of the desired class' name."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: safeMetaCast
        APIUID: //test_ref/cpp/clm/OSMetaClassBase/safeMetaCast/OSMetaClassBase*/(constOSMetaClassBase*,constOSMetaClass*)
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " static OSMetaClassBase *"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: me
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: toType
            TYPE: const OSMetaClass *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: checkTypeInst
        APIUID: //test_ref/cpp/clm/OSMetaClassBase/checkTypeInst/bool/(constOSMetaClassBase*,constOSMetaClassBase*)
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " static bool"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: const OSMetaClassBase *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRetain
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRetain/void/(constvoid*)
        ABSTRACT: "<p>Retain a tagged reference in this object.
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRelease
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRelease/void/(constvoid*)
        ABSTRACT: "<p>Release a tagged reference to this object
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: taggedRelease
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/taggedRelease/void/(constvoid*,constint)
        ABSTRACT: "<p>Release a tagged reference to this object and free if retainCount == when on entry
"
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "protected"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: tag
            TYPE: const void *
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: when
            TYPE: const int
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase3
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase3/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase4
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase4/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase5
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase5/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase6
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase6/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Function
        NAME: _RESERVEDOSMetaClassBase7
        APIUID: //test_ref/cpp/instm/OSMetaClassBase/_RESERVEDOSMetaClassBase7/void/()
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "private"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: " virtual void"
        LINENUM: ""
        CLASS: "HeaderDoc::Function"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        OBJECT TYPE: HeaderDoc::Typedef
        NAME: _ptf_t
        APIUID: //test_ref/cpp/tdef/OSMetaClassBase/_ptf_t
        ABSTRACT: ""
        DISCUSSION: "<p></p>"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::Typedef"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "1"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeAlloc
        APIUID: //test_ref/cpp/macro/OSTypeAlloc
        ABSTRACT: "<p>Allocate an instance of the desired object.
"
        DISCUSSION: "<p>The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Name of the desired type to be created."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeID
        APIUID: //test_ref/cpp/macro/OSTypeID
        ABSTRACT: "<p>Given the name of a class return it's typeID
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Name of the desired type, eg. OSObject."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSTypeIDInst
        APIUID: //test_ref/cpp/macro/OSTypeIDInst
        ABSTRACT: "<p>Given a pointer to an object return it's typeID
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>An instance of an OSObject subclass."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSDynamicCast
        APIUID: //test_ref/cpp/macro/OSDynamicCast
        ABSTRACT: "<p>Roughly analogous to (type *) inst, but check if valid first.
"
        DISCUSSION: "<p>OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
"
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Pointer to object that you wish to attempt to type cast.  May be 0."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSCheckTypeInst
        APIUID: //test_ref/cpp/macro/OSCheckTypeInst
        ABSTRACT: "<p>Is the target object a subclass of the reference object?
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: typeinst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Reference instance of an object, desired type."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: inst
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>Instance of object to check for type compatibility."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TREE COUNT: 1
        INDEX GROUP: 
        IS BLOCK: 
        IS AVAILABILITY MACRO: 
        PARSE ONLY: 
        OBJECT TYPE: HeaderDoc::PDefine
        NAME: OSMemberFunctionCast
        APIUID: //test_ref/cpp/macro/OSMemberFunctionCast
        ABSTRACT: "<p>Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
"
        DISCUSSION: ""
        UPDATED: ""
        COPYRIGHT: ""
        HTMLMETA: ""
        PRIVATEDECLARATION: ""
        GROUP: ""
        INDEXGROUP: ""
        THROWS: ""
        XMLTHROWS: ""
        UPDATED: ""
        LINKAGESTATE: ""
        ACCESSCONTROL: "public"
        AVAILABILITY: ""
        LINKUID: ""
        ORIGCLASS: ""
        ISDEFINE: ""
        ISTEMPLATE: ""
        VALUE: "UNKNOWN"
        RETURNTYPE: ""
        LINENUM: ""
        CLASS: "HeaderDoc::PDefine"
        MASTERENUM: ""
        APIREFSETUPDONE: "1"
        TPCDONE: ""
        NOREGISTERUID: ""
        SUPPRESSCHILDREN: "0"
        NAMELINE_DISCUSSION: ""
        HIDEDOC: ""
        HIDESINGLETONS: ""
        HIDECONTENTS: ""
        MAINOBJECT: ""
        LIST ATTRIBUTES: 
        SHORT ATTRIBUTES: <p></p>
        LONG ATTRIBUTES: <p></p>
        PARSED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: cptrtype
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: func
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p></p>"
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
        TAGGED PARAMETERS:
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: type
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The type of pointer function desired."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: self
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The this pointer of the object whose function you wish to cache."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
            TREE COUNT: 0
            INDEX GROUP: 
            IS BLOCK: 
            OBJECT TYPE: HeaderDoc::MinorAPIElement
            NAME: func
            TYPE: 
            APIUID: 
            ABSTRACT: ""
            DISCUSSION: "<p>The pointer to member function itself, something like &Base::func."
            UPDATED: ""
            COPYRIGHT: ""
            HTMLMETA: ""
            PRIVATEDECLARATION: ""
            GROUP: ""
            INDEXGROUP: ""
            THROWS: ""
            XMLTHROWS: ""
            UPDATED: ""
            LINKAGESTATE: ""
            ACCESSCONTROL: ""
            AVAILABILITY: ""
            LINKUID: ""
            ORIGCLASS: ""
            ISDEFINE: ""
            ISTEMPLATE: ""
            VALUE: "UNKNOWN"
            RETURNTYPE: ""
            LINENUM: ""
            CLASS: "HeaderDoc::MinorAPIElement"
            MASTERENUM: ""
            APIREFSETUPDONE: "1"
            TPCDONE: ""
            NOREGISTERUID: ""
            SUPPRESSCHILDREN: ""
            NAMELINE_DISCUSSION: ""
            HIDEDOC: ""
            HIDESINGLETONS: ""
            HIDECONTENTS: ""
            MAINOBJECT: ""
            LIST ATTRIBUTES: 
            SHORT ATTRIBUTES: <p></p>
            LONG ATTRIBUTES: <p></p>
-=: NAMED OBJECT PARSE TREES :=-
OBJECT: OSMetaClassBase (HeaderDoc::CPPClass)
+---class
+--- 
+---OSMetaClassBase
+---[ NEWLINE ]
+---{
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeAlloc
|   |   +---
@abstract Allocate an instance of the desired object.
|   |   +---
@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
|   |   +---
@param type Name of the desired type to be created.
|   |   +---
@result 'this' if object cas been successfully created.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeAlloc
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---alloc
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeID
|   |   +---
@abstract Given the name of a class return it's typeID
|   |   +---
@param type Name of the desired type, eg. OSObject.
|   |   +---
@result A unique Type ID for the class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeID
|   |   +---(
|   |   +---type
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSTypeIDInst
|   |   +---
@abstract Given a pointer to an object return it's typeID
|   |   +---
@param typeinst An instance of an OSObject subclass.
|   |   +---
@result The typeID, ie. OSMetaClass *.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSTypeIDInst
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +---        
|   |   +---(
|   |   +---(
|   |   +---typeinst
|   |   +---)
|   |   +----
|   |   +--->
|   |   +---getMetaClass
|   |   +---(
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSDynamicCast
|   |   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   |   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   |   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   |   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   |   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSDynamicCast
|   |   +---(
|   |   +---type
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +---        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---(
|   |   +---type
|   |   +--- 
|   |   +---*
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---safeMetaCast
|   |   +---(
|   |   +---(
|   |   +---inst
|   |   +---)
|   |   +---,
|   |   +---  
|   |   +---(
|   |   +---type
|   |   +---::
|   |   +---metaClass
|   |   +---)
|   |   +---)
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSCheckTypeInst
|   |   +---
@abstract Is the target object a subclass of the reference object?
|   |   +---
@param typeinst Reference instance of an object, desired type.
|   |   +---
@param inst Instance of object to check for type compatibility.
|   |   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSCheckTypeInst
|   |   +---(
|   |   +---typeinst
|   |   +---,
|   |   +--- 
|   |   +---inst
|   |   +---)
|   |   +--- 
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---checkTypeInst
|   |   +---(
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---typeinst
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   |   +---[ NEWLINE ]
|   +---//
|   |   +--- 
|   |   +---the conversion of functions that are from MULTIPLY inherited classes.
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-typedef (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---*
|   |   +---_ptf_t
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-static (HAS STATE)
|   +--- 
|   +---inline
|   +--- 
|   +---_ptf_t
|   +---[ NEWLINE ]
|   +---_ptmf2ptf
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   |   +---OSMetaClassBase
|   |   |   +---::
|   |   |   +---*
|   |   |   +---func
|   |   |   +---)
|   |   +---(
|   |   |   +---void
|   |   |   +---)
|   |   +---)
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMemberFunctionCast
|   |   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   |   +---
@param type The type of pointer function desired.
|   |   +---
@param self The this pointer of the object whose function you wish to cache.
|   |   +---
@param func The pointer to member function itself, something like &Base::func.
|   |   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +-*-#define (HAS STATE)
|   |   +--- 
|   |   +---OSMemberFunctionCast
|   |   +---(
|   |   +---cptrtype
|   |   +---,
|   |   +--- 
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---    
|   |   +---(
|   |   +---cptrtype
|   |   +---)
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---                                        
|   |   +---\
|   |   +---[ NEWLINE ]
|   |   +---            
|   |   +---_ptmf2ptf
|   |   +---(
|   |   +---self
|   |   +---,
|   |   +--- 
|   |   +---(
|   |   +---void
|   |   +--- 
|   |   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---)
|   |   +---(
|   |   +---void
|   |   +---)
|   |   +---)
|   |   +--- 
|   |   +---func
|   |   +---)
|   |   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---~
|   +---OSMetaClassBase
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Disable copy constructors of OSMetaClassBase based objects
|   |   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function operator =
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-void (HAS STATE)
|   +--- 
|   +---operator
|   +--- 
|   +---=
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function OSMetaClassBase
|   |   +---
@abstract Disable implicit copy constructor by making private
|   |   +---
@param src Reference to source object that isn't allowed to be copied
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +---(
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---&
|   |   +---src
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Primary implementation of the release mechanism.
|   |   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   |   +---
@param when When retainCount == when then call free(). 
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function getRetainCount
|   |   +---
@abstract How many times has this object been retained?
|   |   +---
@result Current retain count
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---int
|   +--- 
|   +---getRetainCount
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function retain
|   |   +---
@abstract Retain a reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---retain
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function release
|   |   +---
@abstract Release a reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---release
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function serialize
|   |   +---
@abstract 
|   |   +---
@discussion 
|   |   +---
@param s
|   |   +---
@result 
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---serialize
|   +---(
|   |   +---OSSerialize
|   |   +--- 
|   |   +---*
|   |   +---s
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +--- 
|   +---getMetaClass
|   +---(
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function isEqualTo
|   |   +---
@abstract Is this == anObj?
|   |   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   |   +---
@param anObj Object to compare 'this' to.
|   |   +---
@result true if the objects are equivalent, false otherwise.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---bool
|   +--- 
|   +---isEqualTo
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---anObj
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract Check to see if this object is or inherits from the given type.
|   |   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   |   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSSymbol of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSSymbol
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta OSString of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSString
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function metaCast
|   |   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   |   +---
@param toMeta const char * C String of the desired class' name.
|   |   +---
@result 'this' if object is of desired type, otherwise 0.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +-*-OSMetaClassBase (HAS STATE)
|   +--- 
|   +---*
|   +---metaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---char
|   |   +--- 
|   |   +---*
|   |   +---toMeta
|   |   +---)
|   +--- 
|   +---const
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Helper inlines for runtime type preprocessor macros
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---[ NEWLINE ]
|   +---    
|   +---safeMetaCast
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---me
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClass
|   |   +--- 
|   |   +---*
|   |   +---toType
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---    
|   +-*-static (HAS STATE)
|   +--- 
|   +---bool
|   +---[ NEWLINE ]
|   +---    
|   +---checkTypeInst
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---inst
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---OSMetaClassBase
|   |   +--- 
|   |   +---*
|   |   +---typeinst
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---public
|   +---:
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRetain
|   |   +---
@abstract Retain a tagged reference in this object.
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRetain
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +--- 
|   |   +---=
|   |   +--- 
|   |   +---0
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---protected
|   +---:
|   +---[ NEWLINE ]
|   +---/*
|   |   +---!
|   |   +--- @function taggedRelease
|   |   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   |   +---[ NEWLINE ]
|   |   +---*/
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---taggedRelease
|   +---(
|   |   +---const
|   |   +--- 
|   |   +---void
|   |   +--- 
|   |   +---*
|   |   +---tag
|   |   +---,
|   |   +--- 
|   |   +---const
|   |   +--- 
|   |   +---int
|   |   +--- 
|   |   +---when
|   |   +---)
|   +--- 
|   +---const
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---[ NEWLINE ]
|   +---private
|   +---:
|   +---[ NEWLINE ]
|   +---    
|   +---//
|   |   +--- 
|   |   +---Virtual Padding
|   |   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase3
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase4
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase5
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase6
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---    
|   +-*-virtual (HAS STATE)
|   +--- 
|   +---void
|   +--- 
|   +---_RESERVEDOSMetaClassBase7
|   +---(
|   |   +---)
|   +---;
|   +--- 
|   +---[ NEWLINE ]
|   +---}
+---;
+--- 
+---[ NEWLINE ]
END OF OBJECT


OBJECT: _ptmf2ptf (HeaderDoc::Function)
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: ~OSMetaClassBase (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: operator = (HeaderDoc::Function)
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: getRetainCount (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: retain (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: serialize (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: getMetaClass (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: isEqualTo (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: safeMetaCast (HeaderDoc::Function)
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: checkTypeInst (HeaderDoc::Function)
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRetain (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase3 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase4 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase5 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase6 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase7 (HeaderDoc::Function)
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: _ptf_t (HeaderDoc::Typedef)
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeAlloc (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeAlloc
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---(
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +----
|   +--->
|   +---alloc
|   +---(
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeID
|   +---
@abstract Given the name of a class return it's typeID
|   +---
@param type Name of the desired type, eg. OSObject.
|   +---
@result A unique Type ID for the class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeID
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeIDInst
|   +---
@abstract Given a pointer to an object return it's typeID
|   +---
@param typeinst An instance of an OSObject subclass.
|   +---
@result The typeID, ie. OSMetaClass *.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeID (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeID
|   +---(
|   +---type
|   +---)
|   +---        
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSTypeIDInst
|   +---
@abstract Given a pointer to an object return it's typeID
|   +---
@param typeinst An instance of an OSObject subclass.
|   +---
@result The typeID, ie. OSMetaClass *.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSTypeIDInst (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSTypeIDInst
|   +---(
|   +---typeinst
|   +---)
|   +---        
|   +---(
|   +---(
|   +---typeinst
|   +---)
|   +----
|   +--->
|   +---getMetaClass
|   +---(
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSDynamicCast
|   +---
@abstract Roughly analogous to (type *) inst, but check if valid first.
|   +---
@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast<T> operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
|   +---
@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
|   +---
@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
|   +---
@result inst if object non-zero and it is of the desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSDynamicCast (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSDynamicCast
|   +---(
|   +---type
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +---        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---(
|   +---type
|   +--- 
|   +---*
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---safeMetaCast
|   +---(
|   +---(
|   +---inst
|   +---)
|   +---,
|   +---  
|   +---(
|   +---type
|   +---::
|   +---metaClass
|   +---)
|   +---)
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSCheckTypeInst
|   +---
@abstract Is the target object a subclass of the reference object?
|   +---
@param typeinst Reference instance of an object, desired type.
|   +---
@param inst Instance of object to check for type compatibility.
|   +---
@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSCheckTypeInst (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSCheckTypeInst
|   +---(
|   +---typeinst
|   +---,
|   +--- 
|   +---inst
|   +---)
|   +--- 
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---OSMetaClassBase
|   +---::
|   +---checkTypeInst
|   +---(
|   +---inst
|   +---,
|   +--- 
|   +---typeinst
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---[ NEWLINE ]
+---//
|   +--- 
|   +---Arcane evil code interprets a C++ pointer to function as specified in the
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +----fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW
|   +---[ NEWLINE ]
+---//
|   +--- 
|   +---the conversion of functions that are from MULTIPLY inherited classes.
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+-*-typedef (HAS STATE)
+--- 
+---void
+--- 
+---(
|   +---*
|   +---_ptf_t
|   +---)
+---(
|   +---void
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-static (HAS STATE)
+--- 
+---inline
+--- 
+---_ptf_t
+---[ NEWLINE ]
+---_ptmf2ptf
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---self
|   +---,
|   +--- 
|   +---void
|   +--- 
|   +---(
|   |   +---OSMetaClassBase
|   |   +---::
|   |   +---*
|   |   +---func
|   |   +---)
|   +---(
|   |   +---void
|   |   +---)
|   +---)
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMemberFunctionCast
|   +---
@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
|   +---
@param type The type of pointer function desired.
|   +---
@param self The this pointer of the object whose function you wish to cache.
|   +---
@param func The pointer to member function itself, something like &Base::func.
|   +---
@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---[ NEWLINE ]
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT


OBJECT: OSMemberFunctionCast (HeaderDoc::PDefine)
+-*-#define (HAS STATE)
|   +--- 
|   +---OSMemberFunctionCast
|   +---(
|   +---cptrtype
|   +---,
|   +--- 
|   +---self
|   +---,
|   +--- 
|   +---func
|   +---)
|   +---                        
|   +---\
|   +---[ NEWLINE ]
|   +---    
|   +---(
|   +---cptrtype
|   +---)
|   +--- 
|   +---OSMetaClassBase
|   +---::
|   +---                                        
|   +---\
|   +---[ NEWLINE ]
|   +---            
|   +---_ptmf2ptf
|   +---(
|   +---self
|   +---,
|   +--- 
|   +---(
|   +---void
|   +--- 
|   +---(
|   +---OSMetaClassBase
|   +---::
|   +---*
|   +---)
|   +---(
|   +---void
|   +---)
|   +---)
|   +--- 
|   +---func
|   +---)
|   +---[ NEWLINE ]
-=-=-=-=-=-=- EODEC -=-=-=-=-=-=-
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---~
+---OSMetaClassBase
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Disable copy constructors of OSMetaClassBase based objects
|   +---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function operator =
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-void (HAS STATE)
+--- 
+---operator
+--- 
+---=
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function OSMetaClassBase
|   +---
@abstract Disable implicit copy constructor by making private
|   +---
@param src Reference to source object that isn't allowed to be copied
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+---(
|   +---OSMetaClassBase
|   +--- 
|   +---&
|   +---src
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Primary implementation of the release mechanism.
|   +---
@discussion  If $link retainCount <= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. 
|   +---
@param when When retainCount == when then call free(). 
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function getRetainCount
|   +---
@abstract How many times has this object been retained?
|   +---
@result Current retain count
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---int
+--- 
+---getRetainCount
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function retain
|   +---
@abstract Retain a reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---retain
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function release
|   +---
@abstract Release a reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---release
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function serialize
|   +---
@abstract 
|   +---
@discussion 
|   +---
@param s
|   +---
@result 
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---serialize
+---(
|   +---OSSerialize
|   +--- 
|   +---*
|   +---s
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---const
+--- 
+---OSMetaClass
+--- 
+---*
+--- 
+---getMetaClass
+---(
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function isEqualTo
|   +---
@abstract Is this == anObj?
|   +---
@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
|   +---
@param anObj Object to compare 'this' to.
|   +---
@result true if the objects are equivalent, false otherwise.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---bool
+--- 
+---isEqualTo
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---anObj
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract Check to see if this object is or inherits from the given type.
|   +---
@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
|   +---
@param toMeta Pointer to a constant OSMetaClass for the desired target type.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSSymbol of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSSymbol
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta OSString of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---OSString
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function metaCast
|   +---
@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
|   +---
@param toMeta const char * C String of the desired class' name.
|   +---
@result 'this' if object is of desired type, otherwise 0.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+-*-OSMetaClassBase (HAS STATE)
+--- 
+---*
+---metaCast
+---(
|   +---const
|   +--- 
|   +---char
|   +--- 
|   +---*
|   +---toMeta
|   +---)
+--- 
+---const
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Helper inlines for runtime type preprocessor macros
|   +---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---OSMetaClassBase
+--- 
+---*
+---[ NEWLINE ]
+---    
+---safeMetaCast
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---me
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClass
|   +--- 
|   +---*
|   +---toType
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---    
+-*-static (HAS STATE)
+--- 
+---bool
+---[ NEWLINE ]
+---    
+---checkTypeInst
+---(
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---inst
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---OSMetaClassBase
|   +--- 
|   +---*
|   +---typeinst
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---public
+---:
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRetain
|   +---
@abstract Retain a tagged reference in this object.
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS: virtual void _RESERVEDOSMetaClassBase0();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRetain
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase1();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +--- 
|   +---=
|   +--- 
|   +---0
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---protected
+---:
+---[ NEWLINE ]
+---/*
|   +---!
|   +--- @function taggedRelease
|   +---
@abstract Release a tagged reference to this object and free if retainCount == when on entry
|   +---[ NEWLINE ]
|   +---*/
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---WAS:  virtual void _RESERVEDOSMetaClassBase2();
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---taggedRelease
+---(
|   +---const
|   +--- 
|   +---void
|   +--- 
|   +---*
|   +---tag
|   +---,
|   +--- 
|   +---const
|   +--- 
|   +---int
|   +--- 
|   +---when
|   +---)
+--- 
+---const
+--- 
+---=
+--- 
+---0
+---;
+--- 
+---[ NEWLINE ]
+---[ NEWLINE ]
+---private
+---:
+---[ NEWLINE ]
+---    
+---//
|   +--- 
|   +---Virtual Padding
|   +---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase3
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase4
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase5
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase6
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---    
+-*-virtual (HAS STATE)
+--- 
+---void
+--- 
+---_RESERVEDOSMetaClassBase7
+---(
|   +---)
+---;
+--- 
+---[ NEWLINE ]
+---}
END OF OBJECT



-=: HTML OUTPUT OF PARSE TREES :=-
OBJECT: OSMetaClassBase (HeaderDoc::CPPClass)
	<span class="keyword">class</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> { 
	    <span class="keyword">public</span>: <span class="comment">/*! @function OSTypeAlloc
	@abstract Allocate an instance of the desired object.
	@discussion The OSTypeAlloc macro can be used to break the binary compatibility difficulties presented by new.  The problem is that C++ compiles the knowledge of the size of the class into the cade calling new.  If you use the alloc code however the class size is determined by the callee not the caller.
	@param type Name of the desired type to be created.
	@result 'this' if object cas been successfully created.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeAlloc //test_ref/cpp/tdef/OSTypeAlloc //test_ref/cpp/tag/OSTypeAlloc //test_ref/cpp/econst/OSTypeAlloc //test_ref/cpp/struct/OSTypeAlloc //test_ref/cpp/data/OSTypeAlloc //test_ref/cpp/clconst/OSTypeAlloc //test_ref/cpp/intf/OSTypeAlloc //test_ref/cpp/instm/OSTypeAlloc //test_ref/cpp/clm/OSTypeAlloc //test_ref/cpp/intfcm/OSTypeAlloc //test_ref/cpp/intfm/OSTypeAlloc //test_ref/cpp/func/OSTypeAlloc //test_ref/cpp/ftmplt/OSTypeAlloc //test_ref/cpp/defn/OSTypeAlloc //test_ref/cpp/macro/OSTypeAlloc //test_ref/doc/com/intfm/OSTypeAlloc" --><span class="preprocessor">OSTypeAlloc</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/alloc //test_ref/cpp/tdef/alloc //test_ref/cpp/tag/alloc //test_ref/cpp/econst/alloc //test_ref/cpp/struct/alloc //test_ref/cpp/data/alloc //test_ref/cpp/clconst/alloc //test_ref/cpp/intf/alloc //test_ref/cpp/instm/alloc //test_ref/cpp/clm/alloc //test_ref/cpp/intfcm/alloc //test_ref/cpp/intfm/alloc //test_ref/cpp/func/alloc //test_ref/cpp/ftmplt/alloc //test_ref/cpp/defn/alloc //test_ref/cpp/macro/alloc //test_ref/doc/com/intfm/alloc" --><span class="preprocessor">alloc</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSTypeID
	@abstract Given the name of a class return it's typeID
	@param type Name of the desired type, eg. OSObject.
	@result A unique Type ID for the class.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeID //test_ref/cpp/tdef/OSTypeID //test_ref/cpp/tag/OSTypeID //test_ref/cpp/econst/OSTypeID //test_ref/cpp/struct/OSTypeID //test_ref/cpp/data/OSTypeID //test_ref/cpp/clconst/OSTypeID //test_ref/cpp/intf/OSTypeID //test_ref/cpp/instm/OSTypeID //test_ref/cpp/clm/OSTypeID //test_ref/cpp/intfcm/OSTypeID //test_ref/cpp/intfm/OSTypeID //test_ref/cpp/func/OSTypeID //test_ref/cpp/ftmplt/OSTypeID //test_ref/cpp/defn/OSTypeID //test_ref/cpp/macro/OSTypeID //test_ref/doc/com/intfm/OSTypeID" --><span class="preprocessor">OSTypeID</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSTypeIDInst
	@abstract Given a pointer to an object return it's typeID
	@param typeinst An instance of an OSObject subclass.
	@result The typeID, ie. OSMetaClass *.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeIDInst //test_ref/cpp/tdef/OSTypeIDInst //test_ref/cpp/tag/OSTypeIDInst //test_ref/cpp/econst/OSTypeIDInst //test_ref/cpp/struct/OSTypeIDInst //test_ref/cpp/data/OSTypeIDInst //test_ref/cpp/clconst/OSTypeIDInst //test_ref/cpp/intf/OSTypeIDInst //test_ref/cpp/instm/OSTypeIDInst //test_ref/cpp/clm/OSTypeIDInst //test_ref/cpp/intfcm/OSTypeIDInst //test_ref/cpp/intfm/OSTypeIDInst //test_ref/cpp/func/OSTypeIDInst //test_ref/cpp/ftmplt/OSTypeIDInst //test_ref/cpp/defn/OSTypeIDInst //test_ref/cpp/macro/OSTypeIDInst //test_ref/doc/com/intfm/OSTypeIDInst" --><span class="preprocessor">OSTypeIDInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/getMetaClass //test_ref/cpp/tdef/getMetaClass //test_ref/cpp/tag/getMetaClass //test_ref/cpp/econst/getMetaClass //test_ref/cpp/struct/getMetaClass //test_ref/cpp/data/getMetaClass //test_ref/cpp/clconst/getMetaClass //test_ref/cpp/intf/getMetaClass //test_ref/cpp/instm/getMetaClass //test_ref/cpp/clm/getMetaClass //test_ref/cpp/intfcm/getMetaClass //test_ref/cpp/intfm/getMetaClass //test_ref/cpp/func/getMetaClass //test_ref/cpp/ftmplt/getMetaClass //test_ref/cpp/defn/getMetaClass //test_ref/cpp/macro/getMetaClass //test_ref/doc/com/intfm/getMetaClass" --><span class="preprocessor">getMetaClass</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSDynamicCast
	@abstract Roughly analogous to (type *) inst, but check if valid first.
	@discussion OSDynamicCast is an attempt to implement a rudimentary equivalent to rtti's dynamic_cast&lt;T&gt; operator.  Embedded-C++ doesn't allow the use of rtti.  OSDynamicCast is build on the OSMetaClass mechanism.  Note it is safe to call this with a 0 parameter.  
	@param type name of desired class name.  Notice that it is assumed that you desire to cast to a pointer to an object of this type.        Also type qualifiers, like const, are not recognized and will cause an, usually obscure, compile error.
	@param inst Pointer to object that you wish to attempt to type cast.  May be 0.
	@result inst if object non-zero and it is of the desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSDynamicCast //test_ref/cpp/tdef/OSDynamicCast //test_ref/cpp/tag/OSDynamicCast //test_ref/cpp/econst/OSDynamicCast //test_ref/cpp/struct/OSDynamicCast //test_ref/cpp/data/OSDynamicCast //test_ref/cpp/clconst/OSDynamicCast //test_ref/cpp/intf/OSDynamicCast //test_ref/cpp/instm/OSDynamicCast //test_ref/cpp/clm/OSDynamicCast //test_ref/cpp/intfcm/OSDynamicCast //test_ref/cpp/intfm/OSDynamicCast //test_ref/cpp/func/OSDynamicCast //test_ref/cpp/ftmplt/OSDynamicCast //test_ref/cpp/defn/OSDynamicCast //test_ref/cpp/macro/OSDynamicCast //test_ref/doc/com/intfm/OSDynamicCast" --><span class="preprocessor">OSDynamicCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/safeMetaCast //test_ref/cpp/tdef/safeMetaCast //test_ref/cpp/tag/safeMetaCast //test_ref/cpp/econst/safeMetaCast //test_ref/cpp/struct/safeMetaCast //test_ref/cpp/data/safeMetaCast //test_ref/cpp/clconst/safeMetaCast //test_ref/cpp/intf/safeMetaCast //test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast //test_ref/doc/com/intfm/safeMetaCast" --><span class="preprocessor">safeMetaCast</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span>  
	    <span class="comment">/*! @function OSCheckTypeInst
	@abstract Is the target object a subclass of the reference object?
	@param typeinst Reference instance of an object, desired type.
	@param inst Instance of object to check for type compatibility.
	@result false if typeinst or inst are 0 or inst is not a subclass of typeinst's class. true otherwise.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSCheckTypeInst //test_ref/cpp/tdef/OSCheckTypeInst //test_ref/cpp/tag/OSCheckTypeInst //test_ref/cpp/econst/OSCheckTypeInst //test_ref/cpp/struct/OSCheckTypeInst //test_ref/cpp/data/OSCheckTypeInst //test_ref/cpp/clconst/OSCheckTypeInst //test_ref/cpp/intf/OSCheckTypeInst //test_ref/cpp/instm/OSCheckTypeInst //test_ref/cpp/clm/OSCheckTypeInst //test_ref/cpp/intfcm/OSCheckTypeInst //test_ref/cpp/intfm/OSCheckTypeInst //test_ref/cpp/func/OSCheckTypeInst //test_ref/cpp/ftmplt/OSCheckTypeInst //test_ref/cpp/defn/OSCheckTypeInst //test_ref/cpp/macro/OSCheckTypeInst //test_ref/doc/com/intfm/OSCheckTypeInst" --><span class="preprocessor">OSCheckTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/checkTypeInst //test_ref/cpp/tdef/checkTypeInst //test_ref/cpp/tag/checkTypeInst //test_ref/cpp/econst/checkTypeInst //test_ref/cpp/struct/checkTypeInst //test_ref/cpp/data/checkTypeInst //test_ref/cpp/clconst/checkTypeInst //test_ref/cpp/intf/checkTypeInst //test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst //test_ref/doc/com/intfm/checkTypeInst" --><span class="preprocessor">checkTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span>   
	    <span class="comment">// Arcane evil code interprets a C++ pointer to function as specified in the</span> 
	    <span class="comment">// -fapple-kext ABI, i.e. the gcc-2.95 generated code.  IT DOES NOT ALLOW</span> 
	    <span class="comment">// the conversion of functions that are from MULTIPLY inherited classes.</span>  
	    <span class="keyword">typedef</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> (<span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/_ptf_t //test_ref/cpp/clm/_ptf_t //test_ref/cpp/intfcm/_ptf_t //test_ref/cpp/intfm/_ptf_t //test_ref/cpp/func/_ptf_t //test_ref/cpp/ftmplt/_ptf_t //test_ref/cpp/defn/_ptf_t //test_ref/cpp/macro/_ptf_t" --><span class="function">_ptf_t</span><!-- /a -->)(
	        <span class="param">void</span>);  
	    <span class="keyword">static</span> <span class="keyword">inline</span> <!-- a logicalPath="//test_ref/cpp/cl/_ptf_t //test_ref/cpp/tdef/_ptf_t //test_ref/cpp/tag/_ptf_t //test_ref/cpp/econst/_ptf_t //test_ref/cpp/struct/_ptf_t //test_ref/cpp/clconst/_ptf_t //test_ref/cpp/intf/_ptf_t" --><span class="type">_ptf_t</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf" --><span class="function">_ptmf2ptf</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/self //test_ref/cpp/data/self" --><span class="var">self</span><!-- /a -->,
	        <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> (<!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a -->::<span class="type">*</span><span class="param">func</span>)(<!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a -->))   <span class="comment">/*! @function OSMemberFunctionCast
	@abstract Convert a pointer to a member function to a c-style pointer to function.  No warnings are generated.
	@param type The type of pointer function desired.
	@param self The this pointer of the object whose function you wish to cache.
	@param func The pointer to member function itself, something like &amp;Base::func.
	@result A pointer to function of the given type.  This function will panic if an attempt is made to call it with a multiply inherited class.</span>
	        <span class="comment">*/</span>
	    <span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMemberFunctionCast //test_ref/cpp/tdef/OSMemberFunctionCast //test_ref/cpp/tag/OSMemberFunctionCast //test_ref/cpp/econst/OSMemberFunctionCast //test_ref/cpp/struct/OSMemberFunctionCast //test_ref/cpp/data/OSMemberFunctionCast //test_ref/cpp/clconst/OSMemberFunctionCast //test_ref/cpp/intf/OSMemberFunctionCast //test_ref/cpp/instm/OSMemberFunctionCast //test_ref/cpp/clm/OSMemberFunctionCast //test_ref/cpp/intfcm/OSMemberFunctionCast //test_ref/cpp/intfm/OSMemberFunctionCast //test_ref/cpp/func/OSMemberFunctionCast //test_ref/cpp/ftmplt/OSMemberFunctionCast //test_ref/cpp/defn/OSMemberFunctionCast //test_ref/cpp/macro/OSMemberFunctionCast //test_ref/doc/com/intfm/OSMemberFunctionCast" --><span class="preprocessor">OSMemberFunctionCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	        <!-- a logicalPath="//test_ref/cpp/cl/_ptmf2ptf //test_ref/cpp/tdef/_ptmf2ptf //test_ref/cpp/tag/_ptmf2ptf //test_ref/cpp/econst/_ptmf2ptf //test_ref/cpp/struct/_ptmf2ptf //test_ref/cpp/data/_ptmf2ptf //test_ref/cpp/clconst/_ptmf2ptf //test_ref/cpp/intf/_ptmf2ptf //test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf //test_ref/doc/com/intfm/_ptmf2ptf" --><span class="preprocessor">_ptmf2ptf</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span>  
	    <span class="keyword">protected</span>: <!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> ~<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->();  
	    <span class="keyword">private</span>: <span class="comment">// Disable copy constructors of OSMetaClassBase based objects</span> 
	    <span class="comment">/*! @function operator =
	@abstract Disable implicit copy constructor by making private
	@param src Reference to source object that isn't allowed to be copied</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <span class="keyword">operator</span> =(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>);  
	    <span class="comment">/*! @function OSMetaClassBase
	@abstract Disable implicit copy constructor by making private
	@param src Reference to source object that isn't allowed to be copied</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>);  
	    <span class="keyword">public</span>: <span class="comment">/*! @function release
	@abstract Primary implementation of the release mechanism.
	@discussion  If $link retainCount &lt;= the when argument then call $link free().  This indirect implementation of $link release allows the developer to break reference circularity.  An example of this sort of problem is a parent/child mutual reference, either the parent or child can implement: void release() { release(2); } thus breaking the cirularity. </span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <span class="param">when</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function getRetainCount
	@abstract How many times has this object been retained?
	@result Current retain count</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/getRetainCount //test_ref/cpp/clm/getRetainCount //test_ref/cpp/intfcm/getRetainCount //test_ref/cpp/intfm/getRetainCount //test_ref/cpp/func/getRetainCount //test_ref/cpp/ftmplt/getRetainCount //test_ref/cpp/defn/getRetainCount //test_ref/cpp/macro/getRetainCount" --><span class="function">getRetainCount</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function retain
	@abstract Retain a reference in this object.</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/retain //test_ref/cpp/clm/retain //test_ref/cpp/intfcm/retain //test_ref/cpp/intfm/retain //test_ref/cpp/func/retain //test_ref/cpp/ftmplt/retain //test_ref/cpp/defn/retain //test_ref/cpp/macro/retain" --><span class="function">retain</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
	    <span class="comment">/*! @function release
	@abstract Release a reference to this object</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function serialize
	@abstract 
	@discussion 
	@param s
	@result </span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/serialize //test_ref/cpp/clm/serialize //test_ref/cpp/intfcm/serialize //test_ref/cpp/intfm/serialize //test_ref/cpp/func/serialize //test_ref/cpp/ftmplt/serialize //test_ref/cpp/defn/serialize //test_ref/cpp/macro/serialize" --><span class="function">serialize</span><!-- /a -->(
	        <!-- a logicalPath="//test_ref/cpp/cl/OSSerialize //test_ref/cpp/tdef/OSSerialize //test_ref/cpp/tag/OSSerialize //test_ref/cpp/econst/OSSerialize //test_ref/cpp/struct/OSSerialize //test_ref/cpp/clconst/OSSerialize //test_ref/cpp/intf/OSSerialize" --><span class="type">OSSerialize</span><!-- /a --> <span class="type">*</span><span class="param">s</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span> <!-- a logicalPath="//test_ref/cpp/econst/getMetaClass //test_ref/cpp/data/getMetaClass" --><span class="var">getMetaClass</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function isEqualTo
	@abstract Is this == anObj?
	@discussion OSMetaClassBase::isEqualTo implements this as a shallow pointer comparison.  The OS container classes do a more meaningful comparison.  Your mileage may vary.
	@param anObj Object to compare 'this' to.
	@result true if the objects are equivalent, false otherwise.</span>
	        <span class="comment">*/</span>
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/isEqualTo //test_ref/cpp/clm/isEqualTo //test_ref/cpp/intfcm/isEqualTo //test_ref/cpp/intfm/isEqualTo //test_ref/cpp/func/isEqualTo //test_ref/cpp/ftmplt/isEqualTo //test_ref/cpp/defn/isEqualTo //test_ref/cpp/macro/isEqualTo" --><span class="function">isEqualTo</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/anObj //test_ref/cpp/data/anObj" --><span class="var">anObj</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract Check to see if this object is or inherits from the given type.
	@discussion This function is the guts of the OSMetaClass system.  IODynamicCast, qv, is implemented using this function.
	@param toMeta Pointer to a constant OSMetaClass for the desired target type.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;   
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta OSSymbol of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSSymbol //test_ref/cpp/data/OSSymbol" --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta OSString of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSString //test_ref/cpp/data/OSString" --><span class="var">OSString</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">/*! @function metaCast
	@abstract See OSMetaClassBase::metaCast(const OSMetaClass *)
	@param toMeta const char * C String of the desired class' name.
	@result 'this' if object is of desired type, otherwise 0.</span>
	        <span class="comment">*/</span>
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/char //test_ref/cpp/data/char" --><span class="var">char</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>;  
	    <span class="comment">// Helper inlines for runtime type preprocessor macros</span> 
	    <span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span> <!-- a logicalPath="//test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast" --><span class="function">safeMetaCast</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/me //test_ref/cpp/data/me" --><span class="var">me</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toType //test_ref/cpp/data/toType" --><span class="var">toType</span><!-- /a -->);  
	    <span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst" --><span class="function">checkTypeInst</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/inst //test_ref/cpp/data/inst" --><span class="var">inst</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/typeinst //test_ref/cpp/data/typeinst" --><span class="var">typeinst</span><!-- /a -->);  
	    <span class="keyword">public</span>:  <span class="comment">/*! @function taggedRetain
	@abstract Retain a tagged reference in this object.</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS: virtual void _RESERVEDOSMetaClassBase0();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRetain //test_ref/cpp/clm/taggedRetain //test_ref/cpp/intfcm/taggedRetain //test_ref/cpp/intfm/taggedRetain //test_ref/cpp/func/taggedRetain //test_ref/cpp/ftmplt/taggedRetain //test_ref/cpp/defn/taggedRetain //test_ref/cpp/macro/taggedRetain" --><span class="function">taggedRetain</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="comment">/*! @function taggedRelease
	@abstract Release a tagged reference to this object</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS:  virtual void _RESERVEDOSMetaClassBase1();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">protected</span>: <span class="comment">/*! @function taggedRelease
	@abstract Release a tagged reference to this object and free if retainCount == when on entry</span>
	        <span class="comment">*/</span>
	    <span class="comment">// WAS:  virtual void _RESERVEDOSMetaClassBase2();</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a -->,
	        <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/int //test_ref/cpp/data/int" --><span class="var">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/econst/when //test_ref/cpp/data/when" --><span class="var">when</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>;  
	    <span class="keyword">private</span>: <span class="comment">// Virtual Padding</span> 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/func/_RESERVEDOSMetaClassBase3 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase3 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase3 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase3" --><span class="function">_RESERVEDOSMetaClassBase3</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/func/_RESERVEDOSMetaClassBase4 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase4 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase4 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase4" --><span class="function">_RESERVEDOSMetaClassBase4</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/func/_RESERVEDOSMetaClassBase5 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase5 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase5 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase5" --><span class="function">_RESERVEDOSMetaClassBase5</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/func/_RESERVEDOSMetaClassBase6 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase6 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase6 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase6" --><span class="function">_RESERVEDOSMetaClassBase6</span><!-- /a -->(); 
	    <span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/func/_RESERVEDOSMetaClassBase7 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase7 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase7 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase7" --><span class="function">_RESERVEDOSMetaClassBase7</span><!-- /a -->(); 
	};  
END OF OBJECT


OBJECT: _ptmf2ptf (HeaderDoc::Function)
	<span class="keyword">static</span> <span class="keyword">inline</span> <!-- a logicalPath="//test_ref/cpp/cl/_ptf_t //test_ref/cpp/tdef/_ptf_t //test_ref/cpp/tag/_ptf_t //test_ref/cpp/econst/_ptf_t //test_ref/cpp/struct/_ptf_t //test_ref/cpp/clconst/_ptf_t //test_ref/cpp/intf/_ptf_t" --><span class="type">_ptf_t</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf" --><span class="function">_ptmf2ptf</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/self //test_ref/cpp/data/self" --><span class="var">self</span><!-- /a -->,
	    <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> (<!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a -->::<span class="type">*</span><span class="param">func</span>)(<!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a -->)) 
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(); 
END OF OBJECT


OBJECT: ~OSMetaClassBase (HeaderDoc::Function)
	<span class="keyword">virtual</span> ~<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(); 
END OF OBJECT


OBJECT: operator = (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <span class="keyword">operator</span> =(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>); 
END OF OBJECT


OBJECT: OSMetaClassBase (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase" --><span class="function">OSMetaClassBase</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> &amp;<span class="param">src</span>); 
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <span class="param">when</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: getRetainCount (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/int //test_ref/cpp/tdef/int //test_ref/cpp/tag/int //test_ref/cpp/econst/int //test_ref/cpp/struct/int //test_ref/cpp/clconst/int //test_ref/cpp/intf/int" --><span class="type">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/getRetainCount //test_ref/cpp/clm/getRetainCount //test_ref/cpp/intfcm/getRetainCount //test_ref/cpp/intfm/getRetainCount //test_ref/cpp/func/getRetainCount //test_ref/cpp/ftmplt/getRetainCount //test_ref/cpp/defn/getRetainCount //test_ref/cpp/macro/getRetainCount" --><span class="function">getRetainCount</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: retain (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/retain //test_ref/cpp/clm/retain //test_ref/cpp/intfcm/retain //test_ref/cpp/intfm/retain //test_ref/cpp/func/retain //test_ref/cpp/ftmplt/retain //test_ref/cpp/defn/retain //test_ref/cpp/macro/retain" --><span class="function">retain</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: release (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/release //test_ref/cpp/clm/release //test_ref/cpp/intfcm/release //test_ref/cpp/intfm/release //test_ref/cpp/func/release //test_ref/cpp/ftmplt/release //test_ref/cpp/defn/release //test_ref/cpp/macro/release" --><span class="function">release</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: serialize (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/serialize //test_ref/cpp/clm/serialize //test_ref/cpp/intfcm/serialize //test_ref/cpp/intfm/serialize //test_ref/cpp/func/serialize //test_ref/cpp/ftmplt/serialize //test_ref/cpp/defn/serialize //test_ref/cpp/macro/serialize" --><span class="function">serialize</span><!-- /a -->(
	    <!-- a logicalPath="//test_ref/cpp/cl/OSSerialize //test_ref/cpp/tdef/OSSerialize //test_ref/cpp/tag/OSSerialize //test_ref/cpp/econst/OSSerialize //test_ref/cpp/struct/OSSerialize //test_ref/cpp/clconst/OSSerialize //test_ref/cpp/intf/OSSerialize" --><span class="type">OSSerialize</span><!-- /a --> <span class="type">*</span><span class="param">s</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: getMetaClass (HeaderDoc::Function)
	<span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span> <!-- a logicalPath="//test_ref/cpp/econst/getMetaClass //test_ref/cpp/data/getMetaClass" --><span class="var">getMetaClass</span><!-- /a -->() <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: isEqualTo (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/isEqualTo //test_ref/cpp/clm/isEqualTo //test_ref/cpp/intfcm/isEqualTo //test_ref/cpp/intfm/isEqualTo //test_ref/cpp/func/isEqualTo //test_ref/cpp/ftmplt/isEqualTo //test_ref/cpp/defn/isEqualTo //test_ref/cpp/macro/isEqualTo" --><span class="function">isEqualTo</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/anObj //test_ref/cpp/data/anObj" --><span class="var">anObj</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSSymbol //test_ref/cpp/data/OSSymbol" --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSString //test_ref/cpp/data/OSString" --><span class="var">OSString</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: metaCast (HeaderDoc::Function)
	<!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/metaCast //test_ref/cpp/clm/metaCast //test_ref/cpp/intfcm/metaCast //test_ref/cpp/intfm/metaCast //test_ref/cpp/func/metaCast //test_ref/cpp/ftmplt/metaCast //test_ref/cpp/defn/metaCast //test_ref/cpp/macro/metaCast" --><span class="function">metaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/char //test_ref/cpp/data/char" --><span class="var">char</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toMeta //test_ref/cpp/data/toMeta" --><span class="var">toMeta</span><!-- /a -->) <span class="keyword">const</span>; 
END OF OBJECT


OBJECT: safeMetaCast (HeaderDoc::Function)
	<span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase" --><span class="type">OSMetaClassBase</span><!-- /a --> <span class="type">*</span> <!-- a logicalPath="//test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast" --><span class="function">safeMetaCast</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/me //test_ref/cpp/data/me" --><span class="var">me</span><!-- /a -->,
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClass //test_ref/cpp/data/OSMetaClass" --><span class="var">OSMetaClass</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/toType //test_ref/cpp/data/toType" --><span class="var">toType</span><!-- /a -->); 
END OF OBJECT


OBJECT: checkTypeInst (HeaderDoc::Function)
	<span class="keyword">static</span> <!-- a logicalPath="//test_ref/cpp/cl/bool //test_ref/cpp/tdef/bool //test_ref/cpp/tag/bool //test_ref/cpp/econst/bool //test_ref/cpp/struct/bool //test_ref/cpp/clconst/bool //test_ref/cpp/intf/bool" --><span class="type">bool</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst" --><span class="function">checkTypeInst</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/inst //test_ref/cpp/data/inst" --><span class="var">inst</span><!-- /a -->,
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase" --><span class="var">OSMetaClassBase</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/typeinst //test_ref/cpp/data/typeinst" --><span class="var">typeinst</span><!-- /a -->); 
END OF OBJECT


OBJECT: taggedRetain (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRetain //test_ref/cpp/clm/taggedRetain //test_ref/cpp/intfcm/taggedRetain //test_ref/cpp/intfm/taggedRetain //test_ref/cpp/func/taggedRetain //test_ref/cpp/ftmplt/taggedRetain //test_ref/cpp/defn/taggedRetain //test_ref/cpp/macro/taggedRetain" --><span class="function">taggedRetain</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a --> = <span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: taggedRelease (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/taggedRelease //test_ref/cpp/clm/taggedRelease //test_ref/cpp/intfcm/taggedRelease //test_ref/cpp/intfm/taggedRelease //test_ref/cpp/func/taggedRelease //test_ref/cpp/ftmplt/taggedRelease //test_ref/cpp/defn/taggedRelease //test_ref/cpp/macro/taggedRelease" --><span class="function">taggedRelease</span><!-- /a -->(
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/void //test_ref/cpp/data/void" --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a logicalPath="//test_ref/cpp/econst/tag //test_ref/cpp/data/tag" --><span class="var">tag</span><!-- /a -->,
	    <span class="keyword">const</span> <!-- a logicalPath="//test_ref/cpp/econst/int //test_ref/cpp/data/int" --><span class="var">int</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/econst/when //test_ref/cpp/data/when" --><span class="var">when</span><!-- /a -->) <span class="keyword">const</span> = <span class="number">0</span>; 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase3 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase3 //test_ref/cpp/func/_RESERVEDOSMetaClassBase3 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase3 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase3 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase3" --><span class="function">_RESERVEDOSMetaClassBase3</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase4 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase4 //test_ref/cpp/func/_RESERVEDOSMetaClassBase4 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase4 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase4 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase4" --><span class="function">_RESERVEDOSMetaClassBase4</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase5 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase5 //test_ref/cpp/func/_RESERVEDOSMetaClassBase5 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase5 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase5 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase5" --><span class="function">_RESERVEDOSMetaClassBase5</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase6 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase6 //test_ref/cpp/func/_RESERVEDOSMetaClassBase6 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase6 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase6 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase6" --><span class="function">_RESERVEDOSMetaClassBase6</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _RESERVEDOSMetaClassBase7 (HeaderDoc::Function)
	<span class="keyword">virtual</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//test_ref/cpp/instm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/clm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfcm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/intfm/_RESERVEDOSMetaClassBase7 //test_ref/cpp/func/_RESERVEDOSMetaClassBase7 //test_ref/cpp/ftmplt/_RESERVEDOSMetaClassBase7 //test_ref/cpp/defn/_RESERVEDOSMetaClassBase7 //test_ref/cpp/macro/_RESERVEDOSMetaClassBase7" --><span class="function">_RESERVEDOSMetaClassBase7</span><!-- /a -->(); 
END OF OBJECT


OBJECT: _ptf_t (HeaderDoc::Typedef)
	<span class="keyword">typedef</span> <!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void" --><span class="type">void</span><!-- /a --> ( <span class="type">*</span><!-- a logicalPath="//test_ref/cpp/instm/_ptf_t //test_ref/cpp/clm/_ptf_t //test_ref/cpp/intfcm/_ptf_t //test_ref/cpp/intfm/_ptf_t //test_ref/cpp/func/_ptf_t //test_ref/cpp/ftmplt/_ptf_t //test_ref/cpp/defn/_ptf_t //test_ref/cpp/macro/_ptf_t" --><span class="function">_ptf_t</span><!-- /a -->)(
	    <span class="param">void</span>); 
END OF OBJECT


OBJECT: OSTypeAlloc (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeAlloc //test_ref/cpp/tdef/OSTypeAlloc //test_ref/cpp/tag/OSTypeAlloc //test_ref/cpp/econst/OSTypeAlloc //test_ref/cpp/struct/OSTypeAlloc //test_ref/cpp/data/OSTypeAlloc //test_ref/cpp/clconst/OSTypeAlloc //test_ref/cpp/intf/OSTypeAlloc //test_ref/cpp/instm/OSTypeAlloc //test_ref/cpp/clm/OSTypeAlloc //test_ref/cpp/intfcm/OSTypeAlloc //test_ref/cpp/intfm/OSTypeAlloc //test_ref/cpp/func/OSTypeAlloc //test_ref/cpp/ftmplt/OSTypeAlloc //test_ref/cpp/defn/OSTypeAlloc //test_ref/cpp/macro/OSTypeAlloc //test_ref/doc/com/intfm/OSTypeAlloc" --><span class="preprocessor">OSTypeAlloc</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/alloc //test_ref/cpp/tdef/alloc //test_ref/cpp/tag/alloc //test_ref/cpp/econst/alloc //test_ref/cpp/struct/alloc //test_ref/cpp/data/alloc //test_ref/cpp/clconst/alloc //test_ref/cpp/intf/alloc //test_ref/cpp/instm/alloc //test_ref/cpp/clm/alloc //test_ref/cpp/intfcm/alloc //test_ref/cpp/intfm/alloc //test_ref/cpp/func/alloc //test_ref/cpp/ftmplt/alloc //test_ref/cpp/defn/alloc //test_ref/cpp/macro/alloc //test_ref/doc/com/intfm/alloc" --><span class="preprocessor">alloc</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSTypeID (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeID //test_ref/cpp/tdef/OSTypeID //test_ref/cpp/tag/OSTypeID //test_ref/cpp/econst/OSTypeID //test_ref/cpp/struct/OSTypeID //test_ref/cpp/data/OSTypeID //test_ref/cpp/clconst/OSTypeID //test_ref/cpp/intf/OSTypeID //test_ref/cpp/instm/OSTypeID //test_ref/cpp/clm/OSTypeID //test_ref/cpp/intfcm/OSTypeID //test_ref/cpp/intfm/OSTypeID //test_ref/cpp/func/OSTypeID //test_ref/cpp/ftmplt/OSTypeID //test_ref/cpp/defn/OSTypeID //test_ref/cpp/macro/OSTypeID //test_ref/doc/com/intfm/OSTypeID" --><span class="preprocessor">OSTypeID</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSTypeIDInst (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSTypeIDInst //test_ref/cpp/tdef/OSTypeIDInst //test_ref/cpp/tag/OSTypeIDInst //test_ref/cpp/econst/OSTypeIDInst //test_ref/cpp/struct/OSTypeIDInst //test_ref/cpp/data/OSTypeIDInst //test_ref/cpp/clconst/OSTypeIDInst //test_ref/cpp/intf/OSTypeIDInst //test_ref/cpp/instm/OSTypeIDInst //test_ref/cpp/clm/OSTypeIDInst //test_ref/cpp/intfcm/OSTypeIDInst //test_ref/cpp/intfm/OSTypeIDInst //test_ref/cpp/func/OSTypeIDInst //test_ref/cpp/ftmplt/OSTypeIDInst //test_ref/cpp/defn/OSTypeIDInst //test_ref/cpp/macro/OSTypeIDInst //test_ref/doc/com/intfm/OSTypeIDInst" --><span class="preprocessor">OSTypeIDInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">-</span><span class="preprocessor">&gt;</span><!-- a logicalPath="//test_ref/cpp/cl/getMetaClass //test_ref/cpp/tdef/getMetaClass //test_ref/cpp/tag/getMetaClass //test_ref/cpp/econst/getMetaClass //test_ref/cpp/struct/getMetaClass //test_ref/cpp/data/getMetaClass //test_ref/cpp/clconst/getMetaClass //test_ref/cpp/intf/getMetaClass //test_ref/cpp/instm/getMetaClass //test_ref/cpp/clm/getMetaClass //test_ref/cpp/intfcm/getMetaClass //test_ref/cpp/intfm/getMetaClass //test_ref/cpp/func/getMetaClass //test_ref/cpp/ftmplt/getMetaClass //test_ref/cpp/defn/getMetaClass //test_ref/cpp/macro/getMetaClass //test_ref/doc/com/intfm/getMetaClass" --><span class="preprocessor">getMetaClass</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSDynamicCast (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSDynamicCast //test_ref/cpp/tdef/OSDynamicCast //test_ref/cpp/tag/OSDynamicCast //test_ref/cpp/econst/OSDynamicCast //test_ref/cpp/struct/OSDynamicCast //test_ref/cpp/data/OSDynamicCast //test_ref/cpp/clconst/OSDynamicCast //test_ref/cpp/intf/OSDynamicCast //test_ref/cpp/instm/OSDynamicCast //test_ref/cpp/clm/OSDynamicCast //test_ref/cpp/intfcm/OSDynamicCast //test_ref/cpp/intfm/OSDynamicCast //test_ref/cpp/func/OSDynamicCast //test_ref/cpp/ftmplt/OSDynamicCast //test_ref/cpp/defn/OSDynamicCast //test_ref/cpp/macro/OSDynamicCast //test_ref/doc/com/intfm/OSDynamicCast" --><span class="preprocessor">OSDynamicCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/safeMetaCast //test_ref/cpp/tdef/safeMetaCast //test_ref/cpp/tag/safeMetaCast //test_ref/cpp/econst/safeMetaCast //test_ref/cpp/struct/safeMetaCast //test_ref/cpp/data/safeMetaCast //test_ref/cpp/clconst/safeMetaCast //test_ref/cpp/intf/safeMetaCast //test_ref/cpp/instm/safeMetaCast //test_ref/cpp/clm/safeMetaCast //test_ref/cpp/intfcm/safeMetaCast //test_ref/cpp/intfm/safeMetaCast //test_ref/cpp/func/safeMetaCast //test_ref/cpp/ftmplt/safeMetaCast //test_ref/cpp/defn/safeMetaCast //test_ref/cpp/macro/safeMetaCast //test_ref/doc/com/intfm/safeMetaCast" --><span class="preprocessor">safeMetaCast</span><!-- /a --><span class="preprocessor">(</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/type //test_ref/cpp/tdef/type //test_ref/cpp/tag/type //test_ref/cpp/econst/type //test_ref/cpp/struct/type //test_ref/cpp/data/type //test_ref/cpp/clconst/type //test_ref/cpp/intf/type //test_ref/cpp/instm/type //test_ref/cpp/clm/type //test_ref/cpp/intfcm/type //test_ref/cpp/intfm/type //test_ref/cpp/func/type //test_ref/cpp/ftmplt/type //test_ref/cpp/defn/type //test_ref/cpp/macro/type //test_ref/doc/com/intfm/type" --><span class="preprocessor">type</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/metaClass //test_ref/cpp/tdef/metaClass //test_ref/cpp/tag/metaClass //test_ref/cpp/econst/metaClass //test_ref/cpp/struct/metaClass //test_ref/cpp/data/metaClass //test_ref/cpp/clconst/metaClass //test_ref/cpp/intf/metaClass //test_ref/cpp/instm/metaClass //test_ref/cpp/clm/metaClass //test_ref/cpp/intfcm/metaClass //test_ref/cpp/intfm/metaClass //test_ref/cpp/func/metaClass //test_ref/cpp/ftmplt/metaClass //test_ref/cpp/defn/metaClass //test_ref/cpp/macro/metaClass //test_ref/doc/com/intfm/metaClass" --><span class="preprocessor">metaClass</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSCheckTypeInst (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSCheckTypeInst //test_ref/cpp/tdef/OSCheckTypeInst //test_ref/cpp/tag/OSCheckTypeInst //test_ref/cpp/econst/OSCheckTypeInst //test_ref/cpp/struct/OSCheckTypeInst //test_ref/cpp/data/OSCheckTypeInst //test_ref/cpp/clconst/OSCheckTypeInst //test_ref/cpp/intf/OSCheckTypeInst //test_ref/cpp/instm/OSCheckTypeInst //test_ref/cpp/clm/OSCheckTypeInst //test_ref/cpp/intfcm/OSCheckTypeInst //test_ref/cpp/intfm/OSCheckTypeInst //test_ref/cpp/func/OSCheckTypeInst //test_ref/cpp/ftmplt/OSCheckTypeInst //test_ref/cpp/defn/OSCheckTypeInst //test_ref/cpp/macro/OSCheckTypeInst //test_ref/doc/com/intfm/OSCheckTypeInst" --><span class="preprocessor">OSCheckTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><!-- a logicalPath="//test_ref/cpp/cl/checkTypeInst //test_ref/cpp/tdef/checkTypeInst //test_ref/cpp/tag/checkTypeInst //test_ref/cpp/econst/checkTypeInst //test_ref/cpp/struct/checkTypeInst //test_ref/cpp/data/checkTypeInst //test_ref/cpp/clconst/checkTypeInst //test_ref/cpp/intf/checkTypeInst //test_ref/cpp/instm/checkTypeInst //test_ref/cpp/clm/checkTypeInst //test_ref/cpp/intfcm/checkTypeInst //test_ref/cpp/intfm/checkTypeInst //test_ref/cpp/func/checkTypeInst //test_ref/cpp/ftmplt/checkTypeInst //test_ref/cpp/defn/checkTypeInst //test_ref/cpp/macro/checkTypeInst //test_ref/doc/com/intfm/checkTypeInst" --><span class="preprocessor">checkTypeInst</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/inst //test_ref/cpp/tdef/inst //test_ref/cpp/tag/inst //test_ref/cpp/econst/inst //test_ref/cpp/struct/inst //test_ref/cpp/data/inst //test_ref/cpp/clconst/inst //test_ref/cpp/intf/inst //test_ref/cpp/instm/inst //test_ref/cpp/clm/inst //test_ref/cpp/intfcm/inst //test_ref/cpp/intfm/inst //test_ref/cpp/func/inst //test_ref/cpp/ftmplt/inst //test_ref/cpp/defn/inst //test_ref/cpp/macro/inst //test_ref/doc/com/intfm/inst" --><span class="preprocessor">inst</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/typeinst //test_ref/cpp/tdef/typeinst //test_ref/cpp/tag/typeinst //test_ref/cpp/econst/typeinst //test_ref/cpp/struct/typeinst //test_ref/cpp/data/typeinst //test_ref/cpp/clconst/typeinst //test_ref/cpp/intf/typeinst //test_ref/cpp/instm/typeinst //test_ref/cpp/clm/typeinst //test_ref/cpp/intfcm/typeinst //test_ref/cpp/intfm/typeinst //test_ref/cpp/func/typeinst //test_ref/cpp/ftmplt/typeinst //test_ref/cpp/defn/typeinst //test_ref/cpp/macro/typeinst //test_ref/doc/com/intfm/typeinst" --><span class="preprocessor">typeinst</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT


OBJECT: OSMemberFunctionCast (HeaderDoc::PDefine)
	<span class="">#define</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMemberFunctionCast //test_ref/cpp/tdef/OSMemberFunctionCast //test_ref/cpp/tag/OSMemberFunctionCast //test_ref/cpp/econst/OSMemberFunctionCast //test_ref/cpp/struct/OSMemberFunctionCast //test_ref/cpp/data/OSMemberFunctionCast //test_ref/cpp/clconst/OSMemberFunctionCast //test_ref/cpp/intf/OSMemberFunctionCast //test_ref/cpp/instm/OSMemberFunctionCast //test_ref/cpp/clm/OSMemberFunctionCast //test_ref/cpp/intfcm/OSMemberFunctionCast //test_ref/cpp/intfm/OSMemberFunctionCast //test_ref/cpp/func/OSMemberFunctionCast //test_ref/cpp/ftmplt/OSMemberFunctionCast //test_ref/cpp/defn/OSMemberFunctionCast //test_ref/cpp/macro/OSMemberFunctionCast //test_ref/doc/com/intfm/OSMemberFunctionCast" --><span class="preprocessor">OSMemberFunctionCast</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/cptrtype //test_ref/cpp/tdef/cptrtype //test_ref/cpp/tag/cptrtype //test_ref/cpp/econst/cptrtype //test_ref/cpp/struct/cptrtype //test_ref/cpp/data/cptrtype //test_ref/cpp/clconst/cptrtype //test_ref/cpp/intf/cptrtype //test_ref/cpp/instm/cptrtype //test_ref/cpp/clm/cptrtype //test_ref/cpp/intfcm/cptrtype //test_ref/cpp/intfm/cptrtype //test_ref/cpp/func/cptrtype //test_ref/cpp/ftmplt/cptrtype //test_ref/cpp/defn/cptrtype //test_ref/cpp/macro/cptrtype //test_ref/doc/com/intfm/cptrtype" --><span class="preprocessor">cptrtype</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor"> </span><span class="preprocessor">\</span> 
	    <!-- a logicalPath="//test_ref/cpp/cl/_ptmf2ptf //test_ref/cpp/tdef/_ptmf2ptf //test_ref/cpp/tag/_ptmf2ptf //test_ref/cpp/econst/_ptmf2ptf //test_ref/cpp/struct/_ptmf2ptf //test_ref/cpp/data/_ptmf2ptf //test_ref/cpp/clconst/_ptmf2ptf //test_ref/cpp/intf/_ptmf2ptf //test_ref/cpp/instm/_ptmf2ptf //test_ref/cpp/clm/_ptmf2ptf //test_ref/cpp/intfcm/_ptmf2ptf //test_ref/cpp/intfm/_ptmf2ptf //test_ref/cpp/func/_ptmf2ptf //test_ref/cpp/ftmplt/_ptmf2ptf //test_ref/cpp/defn/_ptmf2ptf //test_ref/cpp/macro/_ptmf2ptf //test_ref/doc/com/intfm/_ptmf2ptf" --><span class="preprocessor">_ptmf2ptf</span><!-- /a --><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/self //test_ref/cpp/tdef/self //test_ref/cpp/tag/self //test_ref/cpp/econst/self //test_ref/cpp/struct/self //test_ref/cpp/data/self //test_ref/cpp/clconst/self //test_ref/cpp/intf/self //test_ref/cpp/instm/self //test_ref/cpp/clm/self //test_ref/cpp/intfcm/self //test_ref/cpp/intfm/self //test_ref/cpp/func/self //test_ref/cpp/ftmplt/self //test_ref/cpp/defn/self //test_ref/cpp/macro/self //test_ref/doc/com/intfm/self" --><span class="preprocessor">self</span><!-- /a --><span class="preprocessor">,</span><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor"> </span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/OSMetaClassBase //test_ref/cpp/tdef/OSMetaClassBase //test_ref/cpp/tag/OSMetaClassBase //test_ref/cpp/econst/OSMetaClassBase //test_ref/cpp/struct/OSMetaClassBase //test_ref/cpp/data/OSMetaClassBase //test_ref/cpp/clconst/OSMetaClassBase //test_ref/cpp/intf/OSMetaClassBase //test_ref/cpp/instm/OSMetaClassBase //test_ref/cpp/clm/OSMetaClassBase //test_ref/cpp/intfcm/OSMetaClassBase //test_ref/cpp/intfm/OSMetaClassBase //test_ref/cpp/func/OSMetaClassBase //test_ref/cpp/ftmplt/OSMetaClassBase //test_ref/cpp/defn/OSMetaClassBase //test_ref/cpp/macro/OSMetaClassBase //test_ref/doc/com/intfm/OSMetaClassBase" --><span class="preprocessor">OSMetaClassBase</span><!-- /a --><span class="preprocessor">::</span><span class="preprocessor">*</span><span class="preprocessor">)</span><span class="preprocessor">(</span><!-- a logicalPath="//test_ref/cpp/cl/void //test_ref/cpp/tdef/void //test_ref/cpp/tag/void //test_ref/cpp/econst/void //test_ref/cpp/struct/void //test_ref/cpp/data/void //test_ref/cpp/clconst/void //test_ref/cpp/intf/void //test_ref/cpp/instm/void //test_ref/cpp/clm/void //test_ref/cpp/intfcm/void //test_ref/cpp/intfm/void //test_ref/cpp/func/void //test_ref/cpp/ftmplt/void //test_ref/cpp/defn/void //test_ref/cpp/macro/void //test_ref/doc/com/intfm/void" --><span class="preprocessor">void</span><!-- /a --><span class="preprocessor">)</span><span class="preprocessor">)</span><span class="preprocessor"> </span><!-- a logicalPath="//test_ref/cpp/cl/func //test_ref/cpp/tdef/func //test_ref/cpp/tag/func //test_ref/cpp/econst/func //test_ref/cpp/struct/func //test_ref/cpp/data/func //test_ref/cpp/clconst/func //test_ref/cpp/intf/func //test_ref/cpp/instm/func //test_ref/cpp/clm/func //test_ref/cpp/intfcm/func //test_ref/cpp/intfm/func //test_ref/cpp/func/func //test_ref/cpp/ftmplt/func //test_ref/cpp/defn/func //test_ref/cpp/macro/func //test_ref/doc/com/intfm/func" --><span class="preprocessor">func</span><!-- /a --><span class="preprocessor">)</span> 
END OF OBJECT



$1|C$6|parser